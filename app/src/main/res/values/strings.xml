<resources>
    <string name="app_name">DataStructures</string>
    <string name="navigation_drawer_open">Open navigation drawer</string>
    <string name="navigation_drawer_close">Close navigation drawer</string>
    <string name="nav_header_title">Android Studio</string>
    <string name="nav_header_subtitle">android.studio@android.com</string>
    <string name="nav_header_desc">Navigation header</string>
    <string name="action_settings">Settings</string>

    <string name="menu_home">Home</string>
    <string name="menu_gallery">Gallery</string>
    <string name="menu_slideshow">Slideshow</string>
    <string name="menu_tools">Tools</string>
    <string name="menu_share">Share</string>
    <string name="menu_send">Send</string>
    <string name="data_structures">Data Structures</string>
    <string name="properties">Properties</string>
    <string name="example_code">Example Code</string>
    <string name="terminologies">Terminologies</string>
    <string name="steps">Steps to perform</string>
    <string name="comp">Complexity of Operations</string>
    <string name="implementation">Implementation</string>


    <string name="ds_text">A data structure is a model where data is organized, managed and stored
        in a format that enables efficient access and modification of data. \n\nDifferent forms of
        data may require different types of data structures. \n\nA program built using improper data
        structures will be therefore inefficient or unnecessarily complex. It is necessary to have
        a good knowledge of data structures and understand where to usee the best one.</string>

    <string name="inbuilt_data_structures">Inbuilt Data Structures</string>

    <string name="adt_text">Abstract Data Types are defined by its behaviour from the point of view
        of the user of the data. It defines it in terms of possible values, operation on data, and
        the behaviour of these operations. \n\nThe definition of ADT only mentions what operations
        are to be performed but not how these operations will be implemented. It does not specify
        how the data is being handled under the hood, this is known as abstraction.</string>


    <string name="ll_text">Consists of nodes, where each node poins to some other node forming a
        sequence.</string>

    <string name="stack_text">The insertion and deletion operations are performed at only one end.
        It follows the LIFO principle.</string>

    <string name="queue_text">The insertion and deletion operations are performed at two different
        ends. It follows the FIFO principle</string>

    <string name="tree_text">Hierarchical data structure where the information is represented in
        the form of a parent and children.</string>

    <string name="heap_text">Specialized tree-based data structure that satisfies the heap
        property.</string>

    <string name="graph_text">Consists of nodes and edges used to represent relation between pairs
        of objects.</string>

    <string name="hash_text">Data is stored in an associative manner. A hash function is used to
        map the data to array positions.</string>

    <string name="ids_text">Inbuilt data structures are provided by most programming languages.
        They may be used to derive other data structures.</string>


    <!-- ARRAY -->
    <string name="arr">Array</string>
    <string name="what_arr">What is an array?</string>

    <string name="ans_arr">An array holds a fixed number of similar elements that are stored under
        one name. These elements are stored in contagious memory locations.
        \n\nMost modern programming languages have arrays built-in by default.</string>

    <string name="why_arr">Why use arrays over variables?</string>

    <string name="ans_why_arr">Consider a case where we have to store the marks of all students in
        an university. \n\nWe could do this without using arrays (using variables), but considering
        the large number of students, we would have to declare a large number variables and then
        access each of them separately. This is extremely tedious. \n\nIn these cases, an array is
        preferred as it can hold the same type of data (here, marks of the type integer). Every
        student\'s marks can be accessed by iterating through the indices of the array.
    </string>


    <string name="arr_prop">\t\t1. An array is a data type which can store multiple values of same data type
        at a time.
        \n\t\t2. The items are stored in continuous memory locations with a single
        name.
        \n\t\t3. Arrays cannot be resized dynamically. This may cause memory assigned to
        be wasted or insufficient.
        \n\t\t4. The access time of each element is constant, that is O(1).</string>

    <string name="acc_arr">Access \nO(1)</string>
    <string name="search_arr">Search \nO(n)</string>
    <string name="insertion_arr">Insertion \nO(n)</string>
    <string name="del_arr">Deletion \nO(n)</string>
    <string name="space_arr">Space \nO(n)</string>

    <string name="declaring_arr">Declaring an Array</string>

    <string name="declaring_ans_arr">An array must be declared before it can be used. Declaring an
        array involves specifying the following:\n\n

        \t\t1. data type: the kind of values it can store, e.g, int, char, float
        \n\t\t2. name: used to identify the array
        \n\\tt3. size: maximum number of values the array can store

        \n\nThe syntax for declaring an array is as follows:</string>

    <string name="arr_syn_1">type name[size];</string>

    <string name="calc_arr">Calculating the Address of Array Elements</string>

    <string name="calc_txt">Since an array stores all its data elements in consecutive memory
        locations, storing just the base address, that is, the address of the first element in the
        array, is sufficient.

        \n\nThe address of other data elements can be then calculated using the base address.
        A simple formula can be used: </string>


    <string name="arr_syn_2">A[k] = base_address(A) + size_of_element(k – lower_bound)</string>

    <string name="mda">Multidimensional Arrays</string>

    <string name="mda_txt">Multidimensional arrays can be defined in simple words as array of
        arrays.\n\n

        Data in a two-dimensional array, for example, can be visualised as a table.\n\n

        Each element in a multidimensional array can be accessed by specifying one or
        more indices.</string>

    <string name="dec_2d_arr">Declaring a 2D Array</string>

    <string name="dec_txt_2d">A 2D array can be declared using the follwing syntax:</string>

    <string name="arr_syn_3">type name[row_size][column_size]</string>

    <string name="acc_2d">Accessing 2D Arrays</string>

    <string name="acc_2d_txt">A specific element in a 2D array could be accessed by defining the
        row and column number of the element to be accessed:</string>

    <string name="arr_syn_4">type name[row_number][column_number]</string>

    <string name="rep_2d_mem">Representation of 2D arrays in memory</string>

    <string name="rep_2d_txt">In memory, a 2D array is always stored sequentially.
        There are two ways of storing a two-dimensional array.\n\n

        The memory location of each element in the array could be found out by using the respective
        formulas for both these methods.
    </string>

    <string name="rmf">Row Major Form</string>

    <string name="rmf_txt">In the row major form, the elements are stored row by row. The \'n\'
        elements of the first row are stored in the first \'n\' locations, elements of the second
        row elements are stored in the next \'n\' locations, and so on.
    </string>

    <string name="arr_syn_5">Address(A[I][J]) = base_address + width {number_of_cols (I – 1) + (J – 1)}</string>

    <string name="cmf">Column Major Form</string>

    <string name="cmf_txt">In the column major form, the elements are stored column by column.
        The \'m\' elements of the first column are stored in the first \'m\' locations, elements
        of the second column element are stored in the next \'m\' locations, and so on.
    </string>

    <string name="arr_syn_6">Address(A[I][J]) = base_address + width {number_of_rows (J – 1) + (I – 1)}</string>

    <string name="sm">Sparse Matrix</string>
    <string name="sm_txt">A matrix is known as a sparse matrix when it contains more ZERO values
        than NON-ZERO values. Sparse matrices are used generally because of 2 advantages they
        offer:\n\n

        \t1. Save Space: by storing only the NON-ZERO elements
        \n\t2. Save Computing Time: by storing the elements in way that is efficient for access.
    </string>

    <string name="rep_sm">Representation of Sparse Matrix</string>

    <string name="rep_sm_txt">Sparse Matrices can be represented in more efficient representations
        by using the Triplet Representation or Linked Representation</string>

    <string name="triplet_arr">Array Triplet Representation</string>

    <string name="triplet_arr_txt">In this representation, only the NON-ZERO values are stored 
        along with their row and column positions in the table. The triplet refers to the 
        collection of the row, column and the value.\n\n
        
        The size of the matrix and also the number of NON-ZERO elements are also counted. This is 
        stored in the first field in the array of triplets.
    </string>

    <string name="l_rep">Linked Representation</string>

    <string name="l_rep_txt">A linked list may be used to store a sparse matrix by representing 
        each NON-ZERO value as a node and linking this Node in a specific way such that it 
        represents the position in the original array.\n\n
        Each node in the linked list has four fields corresponding to the row, column, value and 
        pointer to the next node.
    </string>

    <string name="arr_op">Array Operations</string>

    <string name="arr_op_txt">There are 3 basic operations that can be performed in arrays:\n\n
        \t1. Deletion: for deleting an existing element.\n
        \t2. Insertion: for adding a new element.\n
        \t3. Access: for accessing an existing element.
    </string>

    <string name="arr_op_read">Read about Insertion, Deletion and Access</string>

    <string name="algo_arr">Algorithms in Arrays</string>

    <string name="algo_arr_txt">Various searching and sorting algorithms could be
        performed in arrays.</string>

    <string name="searching_arr">Searching</string>
    <string name="ser_arr_txt">Linear and Binary search.</string>

    <string name="sorting_arr">Sorting</string>
    <string name="sort_arr_txt">Bubble, Insertion, Selection, Merge and Quick Sort</string>

    <!--ARRAY OPERATION-->

    <string name="arr_basic_op">There are 3 main operations that can be performed in an array:</string>

    <string name="insert_arr">1. Insert Operation</string>

    <string name="insert_arr_txt">An insertion operation in an array requires us to know the
        index where the element is to be inserted.\n\n
        \t1. If the element is at the end, then it could be directly entered at that position by
        assigning it to that index.\n
        \t2. If the position to be inserted is in-between already present elements of an array,
        then we have to shift all the elements next to the element to be inserted one place after.
        This is a limitation of an array as the memory assigned to an array is continuous.
    </string>

    <string name="arr_syn_7" formatted="false"><![CDATA[void insert_position(int arr[]) {
    int i = 0, pos, num;
    printf("Enter the number to be inserted : ");
    scanf("%d", &num);
    printf("Enter position at which the number is to be added :");
    scanf("%d", &pos);
    for (i = n-1; i>= pos; i—)
        arr[i+1] = arr[i];
    arr[pos] = num;
    n = n + 1;
    display_array(arr);
}]]></string>

    <string name="delete_arr">2. Delete Operation</string>

    <string name="delete_arr_txt">This is similar to the insertion operation, we need to know
        the index of the element to be deleted.\n\n

        \t1. If the element is at the end, then it could be directly deleted (or overwritten) at
        that position.\n
        \t2. If the position to be deleted is in-between already present elements of an array,
        then we have to shift all the elements next to the element to be deleted one place ahead.
    </string>

    <string name="arr_syn_8" formatted="false"><![CDATA[void delete_position(int arr[]) {
    int i, pos;
    printf("\nEnter the position from which the number has to be deleted : ");
    scanf("%d", &pos);
    for (i = pos; i<n-1; i++)
        arr[i] = arr[i+1];
    n = n - 1; // decrease total number of used elements
    display_array(arr);
}]]></string>

    <string name="access_arr">3. Access Operation</string>

    <string name="access_arr_txt">Any array element could be accessed directly by using the
        respective indices.</string>

    <string name="one_arr">One Dimensional Array</string>

    <string name="one_arr_txt">One-dimensional arrays could be accessed with one loop.</string>

    <string name="arr_syn_9" formatted="false"><![CDATA[void display_oneD_array(int arr[100])
{
  int i;
  for(i=0;i<n;i++)
    printf("\n arr[%d] = %d", i, arr[i]);
}]]></string>

    <string name="mda_access_txt">A multi-dimensional array could be accessed by nesting
        multiple loops.</string>

    <string name="arr_syn_10" formatted="false"><![CDATA[
void display_twoD_array(int arr[100][100], int n)
{
  int i,j;
  for(i=0;i<n;i++)
  {
    for(j=0;j<n;j++)
    {
      printf("arr[%d][%d] = %d", i,j, arr[i][j]);
    }
    printf("\n");
  }
}
    ]]></string>


    <!--ARRAY Search-->

    <string name="search_arr_oper">Searching Operation</string>

    <string name="search_arr_oper_txt">Arrays can be searched by comparing the values of some
        array elements with the value required. This can be done in various ways:</string>

    <string name="liner_arr">Linear or Sequential Search</string>

    <string name="liner_arr_txt">The Linear Search algorithm works by sequentially iterating
        through the whole array from one end until the specified element is found.\n\n

        Best Use Case: This search is best used when the list of elements is unsorted and the
        search is to be performed only once.\n\n

        It is also preferred for list to be small, as the time taken grows with the size
        of the data.
    </string>

    <string name="tc_arr">Average Time Complexity: O(n)</string>

    <string name="arr_syn_11" formatted="false"><![CDATA[
int main()
{
  int array[100], search, c, n;

  printf("Enter number of elements in array\n");
  scanf("%d", &n);

  printf("Enter %d integer(s)\n", n);

  for (c = 0; c < n; c++)
    scanf("%d", &array[c]);

  printf("Enter a number to search\n");
  scanf("%d", &search);

  for (c = 0; c < n; c++)
  {
    if (array[c] == search)
    {
      printf("%d is present at location %d.\n", search, c+1);
      break;
    }
  }
  if (c == n)
    printf("%d isn't present in the array.\n", search);

  return 0;
}
    ]]></string>

    <string name="bs_arr">Binary Search</string>

    <string name="bs_arr_txt">
        Binary Search works by halving the number of elements to look through in each iteration,
        hence reducing the number of elements to be searched. This makes it more efficient than the linear search.\n\n

        The only condition for this search to work is that the array must be sorted.\n
        Best Use Case: This search is best used when the list of elements is sorted
        (not always feasible, especially when new elements are to be inserted)\n\n

        The list to be searched can be very large without much decrease in searching time, due to
        the logarithmic nature of the algorithm.
    </string>

    <string name="bs_tc">Average Time Complexity: O(log n)</string>

    <string name="arr_sun_12" formatted="false"><![CDATA[
int main()
{
   int c, first, last, middle, n, search, array[100];

   printf("Enter number of elements\n");
   scanf("%d",&n);

   printf("Enter all %d integers in sorted order\n", n);

   for (c = 0; c < n; c++)
      scanf("%d",&array[c]);

   printf("Enter value to find\n");
   scanf("%d", &search);

   first = 0;
   last = n - 1;
   middle = (first+last)/2;

   while (first <= last) {
      if (array[middle] < search)
         first = middle + 1;
      else if (array[middle] == search) {
         printf("%d found at location %d.\n", search, middle+1);
         break;
      }
      else
         last = middle - 1;

      middle = (first + last)/2;
   }
   if (first > last)
      printf("%d is not found in the array.\n", search);

   return 0;
}
    ]]></string>


    <!--SORTING ARRAY-->

    <string name="sort_oper_arr">Sorting Operation</string>

    <string name="sort_intro_arr">Sorting is the process of arranging a list of elements in a
        particular order (Ascending or Descending). Sorting is used to arrange data, and sometimes
        could be used to reduce the complexity of other algorithms.</string>

    <string name="ie_sort">Internal/External Sorting</string>

    <string name="ie_sort_txt">In internal sorting, all the data to sort is stored in memory all
        the time while sorting is in progress.\n\n

        In external sorting data is stored outside memory (like on disk) and only loaded into
        memory in small chunks. External sorting is usually applied in cases when data can\'t fit
        into memory entirely.
    </string>

    <string name="stab_sort">Stability of Sort</string>

    <string name="stab_sort_txt">A sorting algorithm is said to be stable if two objects with
        equal keys appear in the same order in the sorted output as they appear in the unsorted
        input.\n\n

        A sorting algorithm is said to be unstable if there are two or more objects with equal
        keys which don’t appear in same order before and after sorting.
    </string>

    <string name="bub_sort">1. Bubble Sort</string>

    <string name="bub_sort_txt">
        Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the
        adjacent elements if they are in wrong order. The pass through the list is repeated until
        the list is sorted.\n\n

        \tAverage Time Complexity: O(n ^ 2)\n
        \tWorst Time Complexity: O(n ^ 2)\n
        \tSpace Complexity: O(1)\n
        \tStability: Stable\n
    </string>

    <string name="arr_syn_13" formatted="false"><![CDATA[
int main()
{
  int a[20],n,i,j,temp;
  printf("Enter the number of elements: ");
  scanf("%d",&n);
  printf("Enter the elements: ");

  for(i=0;i<n;++i)
    scanf("%d",&a[i]);

  for (i = 1; i < n; i++)
    for (j = 0; j < (n - i); j++)
      if (a[j] > a[j+1])
      {
        temp = a[j];
        a[j] = a[j+1];
        a[j+1] = temp;
      }

  printf("\nArray after sorting: ");
  for(i=0;i<n;++i)
    printf("%d ",a[i]);
  return 0;
}
    ]]></string>

    <string name="ins_sort">2. Insertion Sort</string>

    <string name="ins_sort_txt">In insertion sort, every iteration moves an element from unsorted
        portion to sorted portion until all the elements are sorted in the list. An analogy of
        insertion sort is the sorting of a deck of cards with our hands.\n\n

        \tAverage Time Complexity: O(n ^ 2)\n
        \tWorst Time Complexity: O(n ^ 2)\n
        \tSpace Complexity: O(1)\n
        \tStability: Stable
    </string>

    <string name="ins_sort_steps">
        Step 1: Assume that first element in the list is in its sorted portion of the list and
        remaining all elements are in unsorted portion.\n

        Step 2: Take the first element from the unsorted list and insert that element into the sorted
        list in order specified (ascending or descending).\n

        Step 3: Repeat the above process until all the elements from the unsorted list are moved into
        the sorted list.
    </string>

    <string name="arr_syn_14" formatted="false"><![CDATA[
int main()
{
  int data[100],n,temp,i,j;
  printf("Enter number of elements to be sorted:");
  scanf("%d",&n);
  printf("Enter elements: ");
  for(i = 0; i < n; i++)
    scanf("%d",&data[i]);
  for(i = 1; i < n; i++)
  {
    temp = data[i];
    j = i - 1;
    while (temp < data[j] && j>=0)
    {
      data[j + 1] = data[j];
      j = j - 1;
    }
    data[j + 1]=temp;
  }
  printf("Sorted array: ");
  for(i = 0; i < n; i++)
    printf("%d  ",data[i]);
  return 0;
}

    ]]></string>

    <string name="sel_sort">3. Selection Sort</string>

    <string name="set_sort_txt">Selection sort is generally used for sorting files with very
        large records and small keys. The algorithm first divides the input list into two parts:
        the sublist of items already sorted, and the sublist of items remaining to be sorted.\n\n

        The algorithm proceeds by finding the smallest (or largest) element in the unsorted
        sublist, swapping it with the leftmost unsorted element, and moving the sublist boundaries
        one element to the right.\n\n

        After all iterations, the sorted sublist would be the required sorted list.\n\n

        \tAverage Time Complexity: O(n ^ 2)\n
        \tWorst Time Complexity: O(n ^ 2)\n
        \tSpace Complexity: O(1)\n
        \tStability: Unstable\n

    </string>

    <string name="sel_sort_steps">
        \tStep 1: Select the first element of the list.\n
        \tStep 2: Compare the selected element with all other elements in the list.\n
        \tStep 3: For every comparison, if any element is smaller (or larger) than selected
        element, swap these two elements.\n
        \tStep 4: Repeat the same procedure with next position in the list till the entire list
        is sorted.
    </string>

    <string name="note_sel_sort">Notes on Complexity of Selection Sort</string>

    <string name="note_sel_sort_txt">Selection Sort has quadratic time complexity even in the
        best case, making it very inefficient on large lists.\n\n

        It has a advantage in situations where auxiliary space is limited, as it is an
        in-place sort.
    </string>

    <string name="arr_syn_15" formatted="false"><![CDATA[
int main()
{
  int array[100], n, pos, temp, i, j;

  printf("Enter number of elements\n");
  scanf("%d", &n);

  printf("Enter the %d values\n", n);

  for (i = 0; i < n; i++)
    scanf("%d", &array[i]);

  for (i = 0; i < (n - 1); i++)
  {
    pos = i;
    for (j = i + 1; j < n; j++)
    {
      if (array[pos] > array[j])
        pos = j;
    }
    if (pos != i)
    {
      temp = array[i];
      array[i] = array[pos];
      array[pos] = temp;
    }
  }

  printf("Sorted list in ascending order:\n");
  for (i = 0; i < n; i++)
    printf("%d\n", array[i]);
  return 0;
}
    ]]></string>

    <string name="mer_sort">4. Merge Sort</string>

    <string name="mer_sort_txt">Merge sort is a very efficient comparison-based sorting
        algorithm.\n\n

        It is a divide-and-conquer algorithm, which works by repeatedly dividing the array in
        small parts and merging them again in the sorted order required.\n\n

        \tAverage Time Complexity: O(n log n)\n
        \tWorst Time Complexity: O(n log n)\n
        \tSpace Complexity: O(n)\n
        \tStability: Stable\n
    </string>

    <string name="mer_sort_steps">
        \tStep 1: Divide the unsorted list into n sublists, each containing 1 element.\n
        \tStep 2: Repeatedly merge sublists to produce new sorted sublists until there is only
        1 sublist remaining. This will be the sorted list.
    </string>

    <string name="mer_sort_notes">Notes on Complexity of Merge Sort</string>

    <string name="mer_sort_notes_txt">Merge sort has an average and worst-case performance
        of O(n log n).\n\n

        Merge sort\'s most common implementations does not sort in place, therefore, the memory
        size of the input must be allocated for the sorted output to be stored.
    </string>

    <string name="arr_syn_16" formatted="false">
        <![CDATA[
void merge(int a[], int i1, int j1, int i2, int j2)
{
  int temp[50];    // temporary array used
  int i, j, k;
  i = i1;          // beginning of the first list
  j = i2;          // beginning of the second list
  k = 0;

  while (i <= j1 && j <= j2)    // while elements in both lists
  {
    if(a[i]<a[j])
      temp[k++]=a[i++];
    else
      temp[k++]=a[j++];
  }

  while(i <= j1)     // copy remaining elements of the first list
    temp[k++] = a[i++];

  while(j<=j2)       // copy remaining elements of the second list
    temp[k++]=a[j++];

  // transfer elements from temp[] back to a[]
  for(i = i1, j = 0; i <= j2; i++, j++)
      a[i] = temp[j];
}

void mergesort(int a[], int i, int j)
{
  int mid;

  if (i < j)
  {
    mid = (i+j)/2;
    mergesort(a, i, mid);        //left recursion
    mergesort(a, mid + 1, j);    //right recursion
    merge(a, i, mid, mid + 1 ,j);    //merging of two sorted sub-arrays
  }
}

int main()
{
  int a[30], n, i;
  printf("Enter no of elements:");
  scanf("%d", &n);
  printf("Enter array elements:");

  for(i = 0; i < n; i++)
    scanf("%d", &a[i]);

  mergesort(a, 0, n-1);

  printf("\nSorted array is :");

  for(i = 0; i < n; i++)
    printf("%d ", a[i]);

  return 0;
}
        ]]>
    </string>

    <string name="quick_sort">5. Quick Sort</string>

    <string name="quick_sort_txt">
        Quick Sort is an efficient divide-and-conquer algorithm. It divides a large list into
        two smaller sublists based on a pivot chosen, into smaller and larger elements.
        Quicksort then recursively does this to the sublists finally  producing a sorted list.\n\n

        \tAverage Time Complexity: O(n log n)\n
        \tWorst Time Complexity: O(n ^ 2)\n
        \tSpace Complexity: O(log n)\n
        \tStability: Unstable\n
    </string>

    <string name="quick_sort_steps">
        \tStep 1: Pick an element, called the pivot.\n

        \tStep 2: Partitioning: reorder the array so that all elements with values less than
        the pivot come before the pivot, while all elements with values greater than the pivot
        come after it. After this partitioning, the pivot is in its final position. This is called
        the partition operation.\n

        \tStep 3: Recursively apply the above steps to the sub-array of elements with smaller
        values and separately to the sub-array of elements with greater values.\n
    </string>

    <string name="complex_quick">Complexity of Quick Sort</string>

    <string name="complex_quick_txt">
        Average time complexity of Quick Sort is O(n log n), thus it is one of the fastest
        sorting algorithms.\n\n

        Worst case in quicksort occurs when the partition process always picks greatest or smallest
        element as pivot.\n\n

        Considering a partition strategy where last element is always picked as pivot, the worst
        case would occur when the array is already sorted in increasing or decreasing order.\n\n

        It is hence required that the pivot to be picked is strategically selected.\n\n
    </string>

    <string name="arr_syn_17" formatted="false"><![CDATA[
void swap(int a, int b)
{
  int t = a;
  a = b;
  b = t;
}

int partition (int arr[], int low, int high)
{
  int pivot = arr[high];    // pivot
  int i = (low - 1);  // index of smaller element

  for (int j = low; j <= high- 1; j++)
  {
    // if current element is smaller than the pivot
    if (arr[j] < pivot)
    {
      i++;    // increment index of smaller element
      swap(&arr[i], &arr[j]);
    }
  }
  swap(&arr[i + 1], &arr[high]);
  return (i + 1);
}

void quick_sort(int arr[], int low, int high)
{
  if (low < high)
  {
    int pi = partition(arr, low, high);
    quick_sort(arr, low, pi - 1);
    quick_sort(arr, pi + 1, high);
  }
}

int main()
{
  int a[100], n, i;
  printf("No. of elements to sort");
  scanf("%d", &n);
  printf("\nEnter the elements:\n");

  for(i = 0; i < n; i++)
    scanf("%d", &a[i]);

  quick_sort(a, 0, n - 1);
  printf("\nArray after sorting:");

  for(i = 0; i < n; i++)
    printf("%d ",a[i]);

  return 0;
}
    ]]></string>


    <!--STRUCTURE-->

    <string name="structure">Structure</string>

    <string name="what_struct">What is a structure?</string>

    <string name="what_struct_txt">
        The structure data type is a compound data type. It is used for grouping simple data
        types or other compound data types under a common data type. It contains member variable
        names along with their type.\n\n

        In C, \'struct\' is used to specify a structure.
    </string>

    <string name="how_struct">How is it used?</string>

    <string name="how_struct_txt">
        There are some situations when we need to group different types of variables in one group.\n\n

        For example, we may want to store the name, roll number, and age of a student. We may
        define a structure as follows:
    </string>

    <string name="struct_syn_1">
        <![CDATA[
struct student {
    char name[100];
    int roll_no;
    int age;
}
        ]]>
    </string>

    <string name="how_struct_txt2">
        When using this structure, we first create a variable of this type. This variable can be
        used as a group and other variables could be referred to by using the dot notation.
    </string>

    <string name="struct_syn_2">
        <![CDATA[
// define variable \'student1\' of type \'student\'
struct student student1;

// access using the dot notation
student1.roll_no = 10;
student1.age = 20;
strcpy(student1.name,"Alexa");

printf("%d", student1.roll_no);
        ]]>
    </string>

    <string name="self_struct">Self-Referential Structures</string>

    <string name="self_struct_txt">
        A self referential data structure is essentially a structure definition which includes at
        least one member that is a pointer to the structure of its own kind.\n\n

        Here, such a structure is used for defining a Node in a linked list. A Node has a data
        variable and pointers to next and/or previous elements.
    </string>

    <string name="strucct_syn_3">
        <![CDATA[
struct Node
{
   int data;
   struct Node *next;     // refers to itself
}
        ]]>
    </string>

    <!--Linked List-->

    <string name="ll_what">What is a linked list?</string>

    <string name="ll_what_txt">A linked list is a linear data structure where each element is a
        separate object, known as a node. Each node contains some data and points to the next node
        in the structure, forming a sequence.\n\n

        This structure allows for efficient insertion or removal of elements from any position as only
        the link is needed to be modified to point to some other element.
    </string>

    <string name="node">The Node</string>

    <string name="node_txt">Each node in its basic contains has two portions: the data,
        and references to the next node in the sequence.\n\n

        In C, we define Node as a structure that has the data and the reference pointer information.
    </string>

    <string name="ll_syn_1">
        <![CDATA[
struct node
{
  int data;
  struct node *next;
};
        ]]>
    </string>

    <string name="ll_over_arr">Advantages over an array</string>

    <string name="adv_ll">
         1. Not Fixed in Size: Linked lists are not fixed in size unlike that of arrays, hence they
        can grow and shrink depending on the data to be inserted. Only the amount of memory
        required to store the data is used.\n
        2. Efficient Insertion and Deletion: Insertion and deletion are efficient and take
        constant time as only the links are manipulated, not the actual memory location of the actual elements.
    </string>

    <string name="arr_over_ll">Disadvantages over an array</string>

    <string name="dis_ll">
        1. Slightly more memory usage: as each element has to store its data along with the
        reference information.\n

        2. Sequential Access: Nodes in a linked list must be read in order from the beginning
        as linked lists are inherently sequential access.\n

        3. Difficult reverse traversal: Difficulties arise in linked lists when it comes to reverse
        traversing in a singly linked list. This can be resolved using doubly linked lists, but
        this again increases memory as we have to store the previous reference pointer.
    </string>

    <string name="acc_ll">Access \nO(n)</string>
    <string name="search_ll">Search \nO(n)</string>
    <string name="insertion_ll">Insertion \nO(1)</string>
    <string name="del_ll">Deletion \nO(1)</string>
    <string name="space_ll">Space \nO(n)</string>

    <string name="accessing_ll">Accessing an element in a Linked List</string>

    <string name="accessing_ll_txt">
        An element in a linked list cannot be accessed directly, unlike an array. Thus, one has
        to traverse from one end of the linked list to the element that has to be accessed.\n\n

        This is what causes the average O(n) search and access time in a linked list. Insertion
        and deletion on the other hand is constant time as only a few pointers have to be modified.
    </string>

    <string name="use_ll">Uses of a Linked List</string>

    <string name="use_ll_txt">
        1. Implement other data structures: It is used to implement other data structures such
        as stacks, queues and non-linear ones like trees and graphs.\n\n
        2. Hash Chaining: It has uses in hash chaining for the implementation in open chaining.
    </string>

    <string name="type_ll">Types</string>

    <string name="sll">Singly Linked List</string>
    <string name="sll_txt">Every node has one pointer - next.</string>

    <string name="dll">Doubly Linked List</string>
    <string name="dll_txt">Every node has two pointers: next and previous.</string>

    <string name="cll">Circular Linked List</string>
    <string name="cll_txt">Last node connects to the first node, forming a loop.</string>

    <!-- Singly Linked List-->

    <string name="sll_what">A singly linked list is the simplest type of linked list in which
        every node contains some data and a pointer to the next node. A singly linked list allows
        traversal of data only in one way.</string>

    <string name="bef_imp">Before implementing actual operations</string>

    <string name="steps_sll">
        Step 1: Include all the header files which are used in the program.\n
        Step 2: Declare all the user defined functions.\n
        Step 3: Define a Node structure with two members data and next.\n
        Step 4: Define a Node pointer \'head\' and set it to NULL.\n
    </string>

    <string name="ins_beg">Inserting at Beginning</string>

    <string name="ins_beg_sll">
        Step 1: Create a newNode with given value.\n
        Step 2: Check whether list is Empty (head == NULL)\n
        Step 3: If it is Empty then, set newNode→next = NULL and head = newNode.\n
        Step 4: If it is Not Empty then, set newNode→next = head and head = newNode.\n
    </string>

    <string name="ll_syn_2">
        <![CDATA[
void insertAtBeginning(int value)
{
   struct Node *newNode;
   newNode = (struct Node*)malloc(sizeof(struct Node));
   newNode -> data = value;
   if(head == NULL)
   {
      newNode -> next = NULL;
      head = newNode;
   }
   else
   {
      newNode -> next = head;
      head = newNode;
   }
   printf("\nNode inserted successfully at beginning\n");
}
        ]]>
    </string>

    <string name="ins_end">Inserting at End</string>

    <string name="ins_end_sll">
        Step 1: Create a newNode with given value and newNode → next as NULL.\n
        Step 2: Check whether list is Empty (head == NULL).\n
        Step 3: If it is Empty then, set head = newNode.\n
        Step 4: If it is Not Empty then, define a node pointer temp and initialize with head.\n
        Step 5: Keep moving the temp to its next node until it reaches to the last
        node in the list (until temp → next is equal to NULL).\n
        Step 6: Set temp → next = newNode.
    </string>

    <string name="ll_syn_3">
        <![CDATA[
void insertAtEnd(int value)
{
  struct Node *newNode;
  newNode = (struct Node*)malloc(sizeof(struct Node));
  newNode -> data = value;
  newNode -> next = NULL;
  if(head == NULL)
    head = newNode;
  else
  {
    struct Node *temp = head;
    while(temp -> next != NULL)
      temp = temp -> next;
    temp -> next = newNode;
  }
  printf("\nNode inserted successfully at end\n");
}
        ]]>
    </string>


    <string name="ins_spec">Inserting at a specific position</string>

    <string name="ins_spec_sll">
        Step 1: Create a newNode with given value.\n
        Step 2: Check whether list is Empty (head == NULL).\n
        Step 3: If it is Empty then, set newNode → next = NULL and head = newNode.\n
        Step 4: If it is Not Empty then, define a node pointer temp and initialize with head.\n
        Step 5: Keep moving the temp to its next node until it reaches to the node after which we 
        want to insert the newNode (run a for-loop till position - 1).
        Step 6: Finally, Set newNode → next = temp → next and temp → next = newNode
    </string>

    <string name="ll_syn_4">
        <![CDATA[
void insertPosition(int value, int pos)
{
  int i = 0;
  struct Node *newNode;
  newNode = (struct Node*)malloc(sizeof(struct Node));
  newNode -> data = value;
  if(head == NULL)
  {
    newNode -> next = NULL;
    head = newNode;
  }
  else {
    struct Node *temp = head;
    for (i = 0; i < pos - 1; i++) {
      temp = temp -> next;
    }
    newNode -> next = temp -> next;
    temp -> next = newNode;
  }
  printf("\nNode inserted successfully\n");
}
        ]]>
    </string>

    <string name="del_beg">Deletion at Beginning</string>

    <string name="del_beg_sll">
        Step 1: Check whether list is Empty (head == NULL).\n
        Step 2: If it is Empty then, display "List is Empty!!! Deletion is not possible" and terminate the function.\n
        Step 3: If it is Not Empty then, define a Node pointer "temp" and initialize with head.\n
        Step 4: Check whether list is having only one node (temp → next == NULL).\n
        Step 5: If it is TRUE then set head = NULL and delete temp.\n
        Step 6: If it is FALSE then set head = temp → next, and delete temp.\n
    </string>


    <string name="ll_syn_5">
        <![CDATA[
void removeBeginning()
{
  if (head == NULL)
	  printf("\n\nList is already Empty!");
    else
    {
      struct Node *temp = head;
      if (head -> next == NULL)
      {
	      head = NULL;
	      free(temp);
      }
      else
      {
        head = temp -> next;
        free(temp);
        printf("\nNode deleted at the beginning\n\n");
      }
   }
}
        ]]>
    </string>

    <string name="del_end">Deletion at End</string>

    <string name="del_end_sll">
        Step 1: Check whether list is Empty (head == NULL).\n
        Step 2: If it is Empty then, display "List is Empty." and terminate the function.\n
        Step 3: If it is Not Empty then, define two Node pointers "temp1" and "temp2" and initialize "temp1" with head.\n
        Step 4: Check whether list has only one Node (temp1 → next == NULL).\n
        Step 5: If it is TRUE. Then, set head = NULL and delete temp1. And terminate the function. (Setting Empty list condition).\n
        Step 6: If it is FALSE. Then, set "temp2 = temp1" and move temp1 to its next node. Repeat the same until it reaches to the last node in the list. (until temp1 → next == NULL).\n
        Step 7: Finally, Set temp2 → next = NULL and delete temp1.\n
    </string>

    <string name="ll_syn_6">
        <![CDATA[
void removeEnd()
{
  if(head == NULL)
  {
    printf("\nList is Empty\n");
  }
  else
  {
    struct Node *temp1 = head, *temp2;
    if(head -> next == NULL)
      head = NULL;
    else
    {
      while(temp1 -> next != NULL)
      {
        temp2 = temp1;
        temp1 = temp1 -> next;
      }
      temp2 -> next = NULL;
    }
    free(temp1);
    printf("\nNode deleted at the end\n\n");
  }
}

        ]]>
    </string>

    <string name="del_pos">Deletion at position</string>

    <string name="del_pos_sll">
        Step 1: Check whether list is Empty (head == NULL).\n
        Step 2: If it is Empty then, display "List is Empty" and terminate the function.\n
        Step 3: If it is Not Empty then, define two Node pointers "temp1" and "temp2" and initialize "temp1" with head.\n
        Step 4: If position to be deleted is 1, then Set head = temp1 → next and then free(temp1).\n
        Step 5: Else keep moving the temp1 and temp2 to the position given (run a for-loop to position - 1).\n
        Step 6: If temp1 reaches NULL, Set flag to 0 (signifies whether the element is found in the list).\n
        Step 7: If flag is 1, Set temp2 → next = temp1 → next and free(temp1).\n
        Step 8: Else display "Position exceeds number of elements in linked list. Please try again" and terminate the function.\n
    </string>

    <string name="ll_syn_7">
        <![CDATA[
void removePosition(int pos)
{
  int i, flag = 0;
  struct Node *temp1 = head, *temp2;
  if (pos == 1) {
      head = temp1 -> next;
      free(temp1);
      printf("\nNode deleted\n\n");
  }
  else {
    for (i = 0; i < pos - 1; i++)
    {
      if (temp1 -> next != NULL) {
        temp2 = temp1;
        temp1 = temp1 -> next;
      }
      else {
        flag = 1;
        break;
      }
    }
    if (flag == 0) {
      temp2 -> next = temp1 -> next;
      free(temp1);
      printf("\nNode deleted\n\n");
    }
    else {
      printf("Position exceeds linked list. Please try again");
    }
  }
}
        ]]>
    </string>

    <string name="dp_menu">Driver Program with Menu</string>

    <string name="de_menu_txt">Only the menu code is shown here. Please include all
        necessary header files and define the functions from above.</string>

    <string name="ll_syn_8" formatted="false">
        <![CDATA[
void main()
{
  int choice, value, choice1, pos, del;
  while(1) {
  printf("\n\n------ MENU ------\n");
  printf("1. Insert at beginning\n2. Insert at End\n3. Insert at location\n4. Delete at beginning\n5. Delete at End\n6. Delete at location\n7. Display\n8. Exit\n\nEnter your choice:  ");
  scanf("%d", &choice);
  switch(choice)
  {
    case 1: printf("Enter the value to be insert: ");
            scanf("%d", &value);
            insertAtBeginning(value);
            break;
    case 2: printf("Enter the value to be insert: ");
            scanf("%d", &value);
            insertAtEnd(value);
            break;
    case 3: printf("Enter the value to be insert: ");
            scanf("%d", &value);
            printf("Enter the position after which you want to insert: ");
            scanf("%d", &pos);
            insertPosition(value, pos);
            break;
    case 4: removeBeginning();
            break;
    case 5: removeEnd();
            break;
    case 6: printf("Enter the value which you want to delete: ");
            scanf("%d", &pos);
            removePosition(pos);
            break;
    case 7: display();
            break;
    case 8: exit(0);
    default: printf("\nWrong Input. Please try again!\n\n");
    }
  }
}
        ]]>
    </string>

    <!--DOUBLY LINKED LIST-->

    <string name="steps_dll">
        Step 1: Include all the header files which are used in the program.\n
        Step 2: Declare all the user defined functions.\n
        Step 3: Define a Node structure with three members data, next and previous.\n
        Step 4: Define a Node pointer \'head\' and set it to NULL.\n
    </string>

    <string name="ins_beg_dll">
        Step 1: Create a newNode with given value and newNode → previous as NULL.\n
        Step 2: Check whether list is Empty (head == NULL).\n
        Step 3: If it is Empty then, assign NULL to newNode → next and newNode to head.\n
        Step 4: If it is not Empty then, Set head to newNode → next and newNode to head.\n
    </string>

    <string name="ll_syn_9">
        <![CDATA[
void insertAtBeginning(int value)
{
  struct Node *newNode;
  newNode = (struct Node*)malloc(sizeof(struct Node));
  newNode -> data = value;
  newNode -> previous = NULL;
  if(head == NULL)
  {
    newNode -> next = NULL;
    head = newNode;
  }
  else
  {
    newNode -> next = head;
    head -> previous = newNode;
    head = newNode;
  }
  printf("\nInsertion successful");
}
        ]]>
    </string>

    <string name="ins_end_dll">
        Step 1: Create a newNode with given value and newNode → next as NULL.\n
        Step 2: Check whether list is Empty (head == NULL).\n
        Step 3: If it is Empty, then assign NULL to newNode → previous and newNode to head.\n
        Step 4: If it is not Empty, then, define a node pointer temp and initialize with head.\n
        Step 5: Keep moving the temp to its next node until it reaches to the last node in the list (until temp → next is equal to NULL).\n
        Step 6: Set newNode to temp → next and temp to newNode → previous.\n
    </string>

    <string name="ll_syn_10">
        <![CDATA[
void insertAtEnd(int value)
{
  struct Node *newNode;
  newNode = (struct Node*)malloc(sizeof(struct Node));
  newNode -> data = value;
  newNode -> next = NULL;
  if(head == NULL)
  {
    newNode -> previous = NULL;
    head = newNode;
  }
  else
  {
    struct Node *temp = head;
    while(temp -> next != NULL)
      temp = temp -> next;
    temp -> next = newNode;
    newNode -> previous = temp;
  }
  printf("\nInsertion successful");
}
        ]]>
    </string>

    <string name="ins_spec_dll">
        Step 1: Create a newNode with given value.\n
        Step 2: Check whether list is Empty (head == NULL).\n
        Step 3: If it is Empty then, Set NULL to newNode → previous and newNode → next and newNode to head.\n
        Step 4: Define a temp node pointer and set it to head.\n
        Step 5: Else keep moving the temp to its next node until it reaches to the node after which we want to insert the newNode (run a for-loop till position - 1).\n
        Step 6: If temp reaches the end of the list (temp → next == NULL), Set flag to 0 (signifies element is not found in the list and break out of the loopIf flag is 1, Set newNode → next = temp → next, temp → next → previous = newNode, temp → next = newNode and newNode → previous = temp.\n
    </string>

    <string name="ll_syn_11">
        <![CDATA[
void insertAfter(int value, int pos)
{
  int i, flag = 1;
  struct Node *newNode, *temp = head;
  newNode = (struct Node*)malloc(sizeof(struct Node));
  newNode -> data = value;
  if(head == NULL)
  {
    newNode -> previous = newNode -> next = NULL;
    head = newNode;
  }
  else
  {
  for (i = 0; i < pos - 1; i++) {
    temp = temp -> next;
    if (temp -> next == NULL) {
      flag = 0;
      break;
    }
  }

  if (flag) {
    newNode -> next = temp -> next;
    temp -> next -> previous = newNode;
    temp -> next = newNode;
    newNode -> previous = temp;
    printf("\nInsertion successful\n");
  }
  else
    printf("Number of elements is less than position entered");
  }
}
        ]]>
    </string>

    <string name="del_beg_dll">
        Step 1: Check whether list is Empty (head == NULL).\n
        Step 2: If it is Empty then, display \'List is Empty\' and terminate the function.\n
        Step 3: If it is not Empty then, define a Node pointer \'temp\' and initialize with head.\n
        Step 4: Check whether list is having only one node (temp → previous is equal to temp → next).\n
        Step 5: If it is TRUE, then Set head to NULL and free(temp).\n
        Step 6: If it is FALSE, then Set temp → next to head, head → previous = NULL and free(temp).\n
    </string>

    <string name="ll_syn_12">
        <![CDATA[
void deleteBeginning()
{
  if(head == NULL)
    printf("List is Empty");
  else
  {
    struct Node *temp = head;
    if(temp -> previous == temp -> next) {
      head = NULL;
      free(temp);
    }
    else {
      head = temp -> next;
      head -> previous = NULL;
      free(temp);
    }
    printf("\nDeletion successful");
  }
}
        ]]>
    </string>

    <string name="del_end_dll">
        Step 1: Check whether list is Empty (head == NULL).\n
        Step 2: If it is Empty, then display \'List is Empty\' and terminate the function.\n
        Step 3: If it is not Empty then, define a Node pointer \'temp\' and initialize with head.\n
        Step 4: Check whether list has only one Node (temp → previous and temp → next both are NULL).\n
        Step 5: If it is TRUE, then assign NULL to head and delete temp. And terminate from the function. (Setting Empty list n).\n
        Step 6: If it is FALSE, then keep moving temp until it reaches to the last node in the list. (until temp → next = NULL).\n
        Step 7: Set temp → previous → next = NULL and free(temp).\n
    </string>

    <string name="ll_syn_13">
        <![CDATA[
void deleteEnd()
{
  if(head == NULL)
    printf("List is Empty");
  else
  {
    struct Node *temp = head;
    if(temp -> previous == temp -> next) {
      head = NULL;
      free(temp);
    }
    else {
      while(temp -> next != NULL)
        temp = temp -> next;
      temp -> previous -> next = NULL;
      free(temp);
    }
    printf("\nDeletion successful");
  }
}
        ]]>
    </string>

    <string name="del_spec_dll">
        Step 1: Check whether list is Empty (head == NULL).\n
        Step 2: If it is Empty then, display \'List is Empty\' and terminate the function.\n
        Step 3: If it is not Empty, then define a Node pointer \'temp\' and initialize with head.\n
        Step 4: Keep moving the temp until it reaches to the exact node to be deleted or to the last node.\n
        Step 5: If it is reached to the last node, then display "Given node not found in the list" and terminate the function.\n
        Step 6: If it is reached to the exact node which we want to delete, then check whether list is having only one node or not.\n
        Step 7: If list has only one node and that is the node which is to be deleted then set head to NULL and free(temp).\n
        Step 8: If list contains multiple nodes, then check whether temp is the first node in the list (temp == head).\n
        Step 9: If temp is the first node, then move the head to the next node (head = head → next), set head of previous to NULL (head → previous = NULL) and delete temp.\n
        Step 10: If temp is not the first node, then check whether it is the last node in the list (temp → next == NULL).\n
        Step 11: If temp is the last node then set temp → previous → next = NULL and free(temp).\n
        Step 12: If temp is not the first node and not the last node, then set temp → previous → next = temp → next, temp → next → previous = temp → previous and free(temp).\n
    </string>

    <string name="ll_syn_14">
        <![CDATA[
void deleteSpecific(int delValue)
{
  if(head == NULL)
    printf("List is Empty");
  else
  {
    struct Node *temp = head;
    while(temp -> data != delValue)
    {
      if(temp -> next == NULL)
      {
        printf("\nGiven node is not found in the list");
      }
      else
      {
        temp = temp -> next;
      }
    }
    if(temp == head)
    {
      head = NULL;
      free(temp);
    }
    else
    {
      temp -> previous -> next = temp -> next;
      free(temp);
    }
    printf("\nDeletion successful");
  }
}
        ]]>
    </string>

    <string name="ll_syn_15" formatted="false">
        <![CDATA[
void main()
{
  int choice, value, pos;
  while(1)
  {
    printf("\nDoubly Linked List Operations\n");
    printf("1. Insert at beginning\n2. Insert at End\n3. Insert at location\n4. Delete at beginning\n5. Delete at End\n6. Delete specific node\n7. Display\n8. Exit\n\nEnter your choice:  ");
    scanf("%d",&choice);
    switch(choice)
    {
      case 1: printf("Enter the value to be inserted: ");
              scanf("%d",&value);
              insertAtBeginning(value);
              break;
      case 2: printf("Enter the value to be inserted: ");
              scanf("%d",&value);
              insertAtEnd(value);
              break;
      case 3: printf("Enter the value to be inserted: ");
              scanf("%d",&value);
              printf("Enter the position after which you want to insert: ");
              scanf("%d",&pos);
              insertAfter(value,pos);
              break;
      case 4: deleteBeginning();
              break;
      case 5: deleteEnd();
              break;
      case 6: printf("Enter the Node value to be deleted: ");
              scanf("%d",&pos);
              deleteSpecific(pos);
              break;
      case 7: display();
              break;
      case 8: exit(0);
      default: printf("\nWrong choice. Please try again\n");
    }
  }
}
        ]]>
    </string>

    <!-- CIRCULAR LINKED LIST-->

    <string name="what_cll">
        In a circular linked list, the last node contains a pointer to the first node of the list, forming a loop.\n\n

        While traversing a circular linked list, we can begin at any node and traverse the list in any direction, forward or backward, until we reach the same node where we started.\n\n

        Thus, a circular linked list has no beginning and no ending.
    </string>

    <string name="steps_cll">
        Step 1: Include all the header files which are used in the program.\n
        Step 2: Declare all the user defined functions.\n
        Step 3: Define a Node structure with two members data and next.\n
        Step 4: Define a Node pointer \'head\' and set it to NULL.\n
    </string>

    <string name="ins_beg_cll">
        Step 1: Create a newNode with given value.\n
        Step 2: Check whether list is Empty (head == NULL).\n
        Step 3: If it is Empty then, set head = newNode and newNode→next = head.\n
        Step 4: If it is Not Empty then, define a Node pointer \'temp\' and initialize with \'head\'.\n
        Step 5: Keep moving the \'temp\' to its next node until it reaches to the last node (until \'temp → next == head\').\n
        Step 6: Set \'newNode → next =head\', \'head = newNode\' and \'temp → next = head\'.\n
    </string>

    <string name="ll_syn_17">
        <![CDATA[
void insertAtBeginning(int value)
{
  struct Node *newNode;
  newNode = (struct Node*)malloc(sizeof(struct Node));
  newNode -> data = value;
  if(head == NULL)
  {
    head = newNode;
    newNode -> next = head;
  }
  else
  {
    struct Node *temp = head;
    while(temp -> next != head)
      temp = temp -> next;
    newNode -> next = head;
    head = newNode;
    temp -> next = head;
  }
  printf("\nInsertion successful");
}
        ]]>
    </string>

    <string name="ins_end_cll">
        Step 1: Create a newNode with given value.\n
        Step 2: Check whether list is Empty (head == NULL).\n
        Step 3: If it is Empty then, set head = newNode and newNode → next = head.\n
        Step 4: If it is Not Empty then, define a node pointer temp and initialize with head.\n
        Step 5: Keep moving the temp to its next node until it reaches to the last node in the list (until temp → next == head).\n
        Step 6: Set temp → next = newNode and newNode → next = head.\n
    </string>


    <string name="ll_syn_18">
        void insertAtEnd(int value)
{
  struct Node *newNode;
  newNode = (struct Node*)malloc(sizeof(struct Node));
  newNode -> data = value;
  if(head == NULL)
  {
    head = newNode;
    newNode -> next = head;
  }
  else
  {
    struct Node *temp = head;
    while(temp -> next != head)
      temp = temp -> next;
    temp -> next = newNode;
    newNode -> next = head;
  }
  printf("\nInsertion successful");
}
    </string>

    <string name="ins_spec_cll">
        Step 1: Create a newNode with given value.\n
        Step 2: Check whether list is Empty (head == NULL).\n
        Step 3: If it is Empty then, set head = newNode and newNode → next = head.\n
        Step 4: If it is Not Empty then, define a node pointer temp and initialize with head.\n
        Step 5: Keep moving the temp to its next node until it reaches to the node after which we want to insert the newNode (until temp1 → data is equal to location, here location is the node value after which we want to insert the newNode).\n
        Step 6: Every time check whether temp is reached to the last node or not. If it is reached to last node then display "Given node is not found in the list!!! Insertion not possible!!!" and terminate the function. Otherwise move the temp to next node.\n
        Step 7: If temp is reached to the exact node after which we want to insert the newNode then check whether it is last node (temp → next == head).\n
        Step 8: If temp is last node then set temp → next = newNode and newNode → next = head.\n
        Step 9: If temp is not last node then set newNode → next = temp → next and temp → next = newNode.\n
    </string>

    <string name="ll_syn_19">
        <![CDATA[
void insertAfter(int value, int location)
{
  struct Node *newNode;
  newNode = (struct Node*)malloc(sizeof(struct Node));
  newNode -> data = value;
  if(head == NULL)
  {
    head = newNode;
    newNode -> next = head;
  }
  else
  {
    struct Node *temp = head;
    while(temp -> data != location)
    {
      if(temp -> next == head)
      {
        printf("Given node is not found in the list");
      }
      else
      {
        temp = temp -> next;
      }
    }
    newNode -> next = temp -> next;
    temp -> next = newNode;
    printf("\nInsertion successful");
  }
}
        ]]>
    </string>

    <string name="del_beg_cll">
        Step 1: Check whether list is Empty (head == NULL).\n
        Step 2: If it is Empty then, display "List is Empty" and terminate the function.\n
        Step 3: Else find the last node in the list by running a loop until temp -> next = head, assign this to last.\n
        Step 4: Set last = temp, temp = head, head = head → next, last -> next = head and then free(temp).\n
    </string>

    <string name="ll_syn_20">
        <![CDATA[
void deleteBeginning()
{
  if(head == NULL)
    printf("List is Empty");
  else
  {
    struct Node *temp = head, *last = NULL;
    if(temp -> next == head)
    {
      head = NULL;
      free(temp);
    }
    else{
      while(temp -> next != head)
        temp = temp -> next;
      last = temp;
      temp = head;
      head = head -> next;
      free(temp);
      last -> next = head;
    }
    printf("\nDeletion successful");
  }
}
        ]]>
    </string>


    <string name="del_end_cll">
        Step 1: Check whether list is Empty (head == NULL).\n
        Step 2: If it is Empty then, display "List is Empty!!! Deletion is not possible" and terminate the function.\n
        Step 3: If it is Not Empty then, define two Node pointers \'temp1\' and \'temp2\' and initialize \'temp1\' with head.\n
        Step 4: Check whether list has only one Node (temp1 → next == head).\n
        Step 5: If it is TRUE. Then, set head = NULL and delete temp1. And terminate from the function. (Setting Empty list condition).\n
        Step 6: If it is FALSE. Then, set \'temp2 = temp1\' and move temp1 to its next node. Repeat the same until temp1 reaches to the last node in the list. (until temp1 → next == head).\n
        Step 7: Set temp2 → next = head and delete temp1.\n
    </string>

    <string name="ll_syn_21">
        <![CDATA[
void deleteBeginning()
{
  if(head == NULL)
    printf("List is Empty");
  else
  {
    struct Node *temp = head, *last = NULL;
    if(temp -> next == head)
    {
      head = NULL;
      free(temp);
    }
    else{
      while(temp -> next != head)
        temp = temp -> next;
      last = temp;
      temp = head;
      head = head -> next;
      free(temp);
      last -> next = head;
    }
    printf("\nDeletion successful");
  }
}
        ]]>
    </string>

    <string name="del_spec_cll">
        Step 1: Check whether list is Empty (head == NULL).\n
        Step 2: If it is Empty then, display "List is Empty!!! Deletion is not possible" and terminates the function.\n
        Step 3: If it is Not Empty then, define two Node pointers \'temp1\' and \'temp2\' and initialize \'temp1\' with head.\n
        Step 4: Keep moving the temp1 until it reaches to the exact node to be deleted or to the last node. And every time set \'temp2 = temp1\' before moving the \'temp1\' to its next node.\n
        Step 5: If it is reached to the last node then display "Given node not found in the list! Deletion not possible!!!". And terminate the function.\n
        Step 6: If it is reached to the exact node which we want to delete, then check whether list is having only one node (temp1 → next == head).\n
        Step 7: If list has only one node and that is the node to be deleted then set head = NULL and delete temp1 (free(temp1)).\n
        Step 8: If list contains multiple nodes then check whether temp1 is the first node in the list (temp1 == head).\n
        Step 9: If temp1 is the first node then set temp2 = head and keep moving temp2 to its next node until temp2 reaches to the last node. Then set head = head → next, temp2 → next = head and delete temp1.\n
        Step 10: If temp1 is not first node then check whether it is last node in the list (temp1 → next == head).\n
        Step 11: If temp1 is last node then set temp2 → next = head and delete temp1 (free(temp1)).\n
        Step 12: If temp1 is not first node and not last node then set temp2 → next = temp1 → next and delete temp1 (free(temp1)).\n
    </string>

    <string name="ll_syn_22">
        <![CDATA[
void deleteSpecific(int delValue)
{
  if(head == NULL)
    printf("List is Empty");
  else
  {
    struct Node *temp1 = head, *temp2;
    while(temp1 -> data != delValue)
    {
      if(temp1 -> next == head)
      {
        printf("\nGiven node is not found in the list");
      }
      else
      {
        temp2 = temp1;
        temp1 = temp1 -> next;
      }
    }
    if (temp1 -> next == head) {
      head = NULL;
      free(temp1);
    }
    else {
      if(temp1 == head)
      {
        temp2 = head;
        while(temp2 -> next != head)
            temp2 = temp2 -> next;
        head = head -> next;
        temp2 -> next = head;
        free(temp1);
      }
      else
      {
        if(temp1 -> next == head)
        {
          temp2 -> next = head;
        }
        else
        {
          temp2 -> next = temp1 -> next;
        }
        free(temp1);
      }
    }
    printf("\nDeletion successful");
  }
}
        ]]>
    </string>

    <string name="ll_syn_23" formatted="false">
    <![CDATA[
void main()
{
  int choice,value,choice1,pos,del;
  while(1) {
    printf("\n\nCircular Linked List Menu\n");
    printf("1. Insert at beginning\n2. Insert at End\n3. Insert at location\n4. Delete at beginning\n5. Delete at End\n6. Delete at location\n7. Display\n8. Exit\n\nEnter your choice:  ");
    scanf("%d",&choice);
    switch(choice)
    {
      case 1: printf("Enter the value to be insert: ");
              scanf("%d", &value);
              insertAtBeginning(value);
              break;
      case 2: printf("Enter the value to be insert: ");
              scanf("%d", &value);
              insertAtEnd(value);
              break;
      case 3: printf("Enter the value to be insert: ");
              scanf("%d", &value);
              printf("Enter the element after which you want to insert: ");
              scanf("%d", &pos);
              insertAfter(value, pos);
              break;
      case 4: deleteBeginning();
              break;
      case 5: deleteEnd();
              break;
      case 6: printf("Enter the element after which you want to delete: ");
              scanf("%d", &pos);
              deleteSpecific(pos);
              break;
      case 7: display();
              break;
      case 8: exit(0);
      default: printf("\nWrong Choice\n\n");
    }
  }
}

    ]]>
</string>

    <!--Stack-->

    <string name="what_stack">What is a Stack?</string>

    <string name="what_stack_txt">
        A stack is a linear data structure which stores its elements in particular order. This order followed by a stack is known as LIFO (Last In First Out).\n\n

        A example of real life phenomena of stacks is of plates stacked over one another on a table.\n\n

        The plate which is at the top is the first one to be removed, it is not possible to remove the last plate unless the above plates have been removed, following the principle Last In First Out.
    </string>

    <string name="exam_stack">Examples in Programming</string>

    <string name="exam_stack_txt">
        1. UNDO functionality in text editors: are based on a stack. Every change in the document is added to stack and upon an UNDO request, the last change is referred by popping it from the stack.\n\n
        2. Parentheses checker: the ordered manner of the stack could be used for checking the proper closing of parentheses. Every opening parentheses is pushed on to the stack and for every correct closing parentheses, it is popped off. Irregularities can then be detected if they mismatch.\n\n
        3. Expression parsing: using stacks can help evaluate expressions faster using postfix or prefix notation. See the page below.\n\n
    </string>

    <string name="exp_stack">Expression Parsing using Stacks</string>

    <string name="exp_stack_txt">Infix, Postfix and Prefix Expressions</string>

    <string name="acc_st">Access \nO(n)</string>
    <string name="search_st">Search \nO(n)</string>
    <string name="insertion_st">Insertion \nO(1)</string>
    <string name="del_st">Deletion \nO(1)</string>
    <string name="space_st">Space \nO(n)</string>

    <string name="prop_stack">
        1. Follows LIFO (Last In First Out Order), the last element that is inserted is pushed out first.\n
        2. A pointer keeps track of the stack\'s topmost (or last) element. This is manipulated on the basis of operations to be performed to know keep track of most recent element.
    </string>

    <string name="stack_mani">Stack Manipulation Operations</string>

    <string name="push_oper">1. Push Operation</string>
    <string name="push_oper_txt">
        When an element is inserted into the stack, it is said that the element is pushed into the stack. The top pointer is moved up to point to the element that is inserted.
    </string>

    <string name="pop_oper">2. Pop Operation</string>
    <string name="pop_oper_txt">
        When an element is removed from the stack, it is said that the element is popped from the stack. The top pointer is moved down to point to the element below the removed element.
    </string>

    <string name="peek_oper">3. Peek Operation</string>
    <string name="peek_oper_txt">
        Peek is an operation that returns the value of the topmost element of the stack without deleting it from the stack.
    </string>

    <string name="impl_stack">Implementing a Stack</string>

    <string name="arr_stack">Using Array</string>
    <string name="arr_stack_txt">Using inbuilt array.</string>

    <string name="ll_stack">Using Linked List</string>
    <string name="ll_stack_txt">By implementing a linked list</string>

    <!--stack Expression Parsing-->

    <string name="exp_parsing">What is Expression Parsing?</string>

    <string name="exp_parsing_txt">The way to write arithmetic expressions is known as a notation. An arithmetic expression can be written in three different but equivalent notations, i.e., without changing the essence or output of an expression.</string>

    <string name="infix">Infix Notation</string>

    <string name="infix_txt">
        Operators are written in-between their operands. This is the usual way we write expressions.\n\n

        Infix notation needs extra information to make the order of evaluation of the operators clear: rules built into the language about operator precedence and associativity, and parentheses to allow users to override these rules.\n\n

        Infix notation is more difficult to parse by computers than prefix or postfix.\n
    </string>

    <string name="infix_eg">Example: 3 + 4</string>

    <string name="postfix">Postfix Notation</string>

    <string name="postfix_txt">
        Operators are written after their operands.\n\n

        The order of evaluation of operators is always left-to-right, and brackets cannot be used to change this order.\n\n

        This notation is faster because reverse Polish calculators do not need expressions to be parenthesized, fewer operations need to be entered to perform typical calculations.\n\n
    </string>

    <string name="postfix_eg">Example: 3 4 +</string>

    <string name="prefix">Prefix Notation</string>

    <string name="prefix_txt">
        Operators are written before their operands.\n\n

Operators are evaluated left-to-right and brackets are superfluous. Operators act on the two nearest values on the right.
    </string>

    <string name="prefix_eg">Example: + 3 4</string>

    <!--Stack Using Array-->

    <string name="bef_stack_arr">
        Step 1: Include all header files, define the main function and choose a size for the stack using #define SIZE 100.\n
        Step 2: Create a one dimensional array with fixed size (int stack[SIZE]).\n
        Step 3: Define an integer variable \'top\' and initialize with \'-1\'. (int top = -1).
    </string>

    <string name="push_stack">Push Operation</string>

    <string name="push_stack_arr_txt">
        Step 1: Check whether the stack is FULL. (top == SIZE-1).\n
        Step 2: If it is FULL, then terminate the function with output "Stack is FULL, Insertion not possible".\n
        Step 3: If it is NOT FULL, then increment top value by one (top++) and set stack[top] to value (stack[top] = value).
    </string>

    <string name="stack_syn_1">
        <![CDATA[
void push(int value){
  if(top == SIZE-1)
    printf("\nOverflow. Stack is Full");
  else{
    top++;
    stack[top] = value;
    printf("\nInsertion was successful");
  }
}

        ]]>
    </string>

    <string name="pop_stack">Pop Operation</string>

    <string name="pop_stack_arr_txt">
        Step 1: Check whether stack is EMPTY. (top == -1).\n
        Step 2: If it is EMPTY, then output "Underflow. Stack is empty" and terminate the function.\n
        Step 3: If it is NOT EMPTY, then delete stack[top] and decrement top value by one (top—).
    </string>

    <string name="stack_syn_2">

void pop(){
  if(top == -1)
    printf("\nUnderflow. Stack is empty");
  else{
    printf("\nDeleted : %d", stack[top]);
    top—;
  }
}

    </string>


    <string name="stack_arr_menu">Please include the required header files and define SIZE to the required size of the stack to run the program.</string>

    <string name="stack_syn_3" formatted="false"><![CDATA[

int stack[SIZE], top = -1;

void push(int value) {
  if(top == SIZE-1)
    printf("\nOverflow. Stack is Full");
  else{
    top++;
    stack[top] = value;
    printf("\nInsertion was successful");
  }
}

void pop() {
  if(top == -1)
    printf("\nUnderflow. Stack is empty");
  else{
    printf("\nDeleted : %d", stack[top]);
    top—;
  }
}

void display() {
  if(top == -1)
    printf("\nStack is Empty!");
  else{
    int i;
    printf("\nStack elements are:\n");
    for(i=top; i>=0; i—)
  printf("%d\n",stack[i]);
  }
}

void main()
{
  int value, choice;
  while(1) {
    printf("\n\n------MENU-------\n");
    printf("1. Push\n2. Pop\n3. Display\n4. Exit");
    printf("\nEnter your choice: ");
    scanf("%d",&choice);
    switch(choice){
      case 1: printf("Enter the value to be inserted: ");
              scanf("%d",&value);
              push(value);
              break;
      case 2: pop();
              break;
      case 3: display();
              break;
      case 4: exit(0);
      default: printf("\nWrong selection, please try again.");
    }
  }
}



    ]]></string>

    <!-- Stack using LL-->

    <string name="before_stack_ll">
        Step 1: Include all header files and the main function.\n
        Step 2: Define a \'Node\' structure with two members data and next.\n
        Step 3: Define a Node pointer \'top\' and set it to NULL.
    </string>

    <string name="oush_stack_ll">
        Step 1: Create a newNode with a given value.\n
        Step 2: Check whether stack is Empty (top == NULL).\n
        Step 3: If it is Empty, then set newNode → next = NULL.\n
        Step 4: If it is Not Empty, then set newNode → next = top.\n
        Step 5: Finally, set top = newNode.
    </string>

    <string name="stack_syn_4">
        <![CDATA[
void push(int value)
{
  struct Node *newNode;
  newNode = (struct Node*)malloc(sizeof(struct Node));
  newNode -> data = value;
  if(top == NULL)
    newNode -> next = NULL;
  else
    newNode -> next = top;
  top = newNode;
  printf("\nInsertion is Successful\n");
}
        ]]>
    </string>

    <string name="stack_pop_ll">
        Step 1: Check whether stack is Empty (top == NULL).\n
        Step 2: If it is Empty, then display "Stack is Empty!!! Deletion is not possible!!!" and terminate the function.\n
        Step 3: If it is Not Empty, then define a Node pointer \'temp\' and set it to \'top\'.\n
        Step 4: Then set \'top = top → next\'.\n
        Step 5: Finally, delete \'temp\' (free(temp)).
    </string>

    <string name="stack_syn_5">
        <![CDATA[
void pop()
{
  if (top == NULL)
    printf("\nUnderflow. Stack is empty\n");
  else {
    struct Node *temp = top;
    printf("\nDeleted element is: %d", temp -> data);
    top = temp -> next;
    free(temp);
  }
}
        ]]>
    </string>

    <string name="stack_syn_6" formatted="false">
        <![CDATA[
struct Node
{
  int data;
  struct Node *next;
}*top = NULL;

void push(int value)
{
  struct Node *newNode;
  newNode = (struct Node*)malloc(sizeof(struct Node));
  newNode -> data = value;
  if (top == NULL)
    newNode -> next = NULL;
  else
    newNode -> next = top;
  top = newNode;
  printf("\nInsertion is Successful\n");
}

void pop()
{
  if(top == NULL)
    printf("\nUnderflow. Stack is empty\n");
  else {
    struct Node *temp = top;
    printf("\nDeleted element is: %d", temp -> data);
    top = temp -> next;
    free(temp);
  }
}

void display()
{
  if(top == NULL)
    printf("\nStack is Empty\n");
  else {
    struct Node *temp = top;
    while (temp -> next != NULL){
      printf("%d--->", temp -> data);
      temp = temp -> next;
    }
    printf("%d--->NULL", temp -> data);
  }
}

void main()
{
  int choice, value;
  printf("\nStack using Linked ListS\n");
  while(1) {
    printf("\nStack using Linked Lists\n");
    printf("1. Push\n2. Pop\n3. Display\n4. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &choice);
    switch(choice){
    case 1: printf("Enter the value to be inserted: ");
            scanf("%d", &value);
            push(value);
            break;
    case 2: pop();
            break;
    case 3: display();
            break;
    case 4: exit(0);
    default: printf("\nWrong selection, Please try again\n");
    }
  }
}


        ]]>
    </string>

    <!-- Queue -->

    <string name="what_queue">What is a Queue?</string>

    <string name="what_queue_txt">A queue is a linear data structure which unlike the stack is open at both ends. It follows the FIFO (First In First Out) principle, which means that the element that is inserted first is removed first.</string>

    <string name="real_queue">Real Life Examples of Queues</string>

    <string name="real_queue_txt">
        1. An example of a queue is the queue we see every day in our lives. People join a queue from the end and get out of the queue from the front, following the FIFO principle.\n
        2. A queue is used in process scheduling in the Operating System. A series of processes wait in a queue waiting to be executed when the required resources are free.
    </string>

    <string name="acc_qu">Access \nO(n)</string>
    <string name="search_qu">Search \nO(n)</string>
    <string name="insertion_qu">Insertion \nO(1)</string>
    <string name="del_qu">Deletion \nO(1)</string>
    <string name="space_qu">Space \nO(n)</string>

    <string name="qu_properties">
        1. Follows the FIFO (FIFO In First Out Order), the first element that is inserted, is removed first.\n
        2. Two pointers keep track of the front and rear of the queue, whenever insertion or deletion takes place, these two pointers are updated accordingly to track the last and first element.\n
        3. Insertion takes place from the rear and deletion from the front.
    </string>

    <string name="type_qu">Types of Queues</string>

    <string name="type_qu_txt">
        Queues and their functions can be modified to have some additional advantages, some of the other types of queues are:
    </string>

    <string name="deque">1. Double Ended Queues (Deque)</string>

    <string name="deque_txt">
        A deque is a list in which the elements can be inserted or deleted at either end. These are further of two types:\n\n

        \t1. Input Restricted Queue: Where insertion takes place only from the rear end, deletion can take place from both ends.\n
        \t2. Output Restricted Queue: Where deletion takes place from only the front, however insertion can take place from both ends.

    </string>

    <string name="priority">2. Priority Queues</string>

    <string name="priority_txt">
        Priority queue is like a regular queue or stack data structure, but where additionally each element has a "priority" associated with it. In a priority queue, an element with high priority is served before an element with low priority.\n\n

This can be helped in operations where priority is important for executing operations in a certain order.
    </string>

    <string name="circular_qu">3. Circular Queue (Circular Buffer)</string>

    <string name="circular_qu_txt">A circular queue is a queue that uses a single, fixed-size buffer as if it were connected end-to-end.\n\n

        Circular queue is a good implementation for a queue that has fixed maximum size, as their is no shifting involved and the whole queue can be used up for storing all the elements, which is not possible in an array implementation of linear queue.
    </string>

    <string name="queue_mani">Queue Manipulation Operations</string>

    <string name="qu_mani_txt">Queue has 2 main operations:</string>

    <string name="enqueue">1. Enqueue (Insert/Store) Operation</string>

    <string name="enqueue_txt">When an element is inserted(or stored) into the queue, the operation is called Enqueue. The rear pointer updates to the item just inserted to specify the now last element in the queue.</string>

    <string name="dequeue">2. Dequeue (Delete/Access) Operation</string>

    <string name="dequeue_txt">When an element is deleted(or accessed) from the queue, the operation is called Dequeue. The front pointer updates to the item after the deleted item to specify the now first element in the queue.</string>

    <string name="imple_que">Implementing a Queue</string>


    <!--Queues Array-->
    <string name="before_que_arr">
        Step 1: Include all the header files which are used in the program and define a constant \'SIZE\' with a specific value.\n
        Step 2: Declare all the user-defined functions which are used in queue implementation.\n
        Step 3: Create a one-dimensional array with above-defined SIZE (int queue[SIZE]).\n
        Step 4: Define two integer variables \'front\' and \'rear\' and initialize both with \'-1\'. (int front = -1, rear = -1).\n
    </string>

    <string name="enque_oper">Enqueue Operation</string>

    <string name="enque_arr_txt">
        Step 1: Check whether the queue is FULL. (rear == SIZE-1).\n
        Step 2: If it is FULL, then display "Overflow. The queue is Full." and terminate the function.\n
        Step 3: If it is NOT FULL, then increment rear value by one (rear++) and set queue[rear] = value.\n
    </string>

    <string name="que_syn_1">
        <![CDATA[
void enQueue(int value){
  if(rear == SIZE-1)
    printf("\nOverflow. Queue is Full.");
  else {
    if(front == -1)
  front = 0;
    rear++;
    queue[rear] = value;
    printf("\nInsertion was successful");
  }
}
        ]]>
    </string>

    <string name="dequeue_oper">Dequeue Operation</string>


    <string name="dequeue_arr_txt">
        Step 1: Check whether queue is EMPTY. (front == rear).\n
        Step 2: If it is EMPTY, then display "Underflow. Queue is Empty." and terminate the function.\n
        Step 3: If it is NOT EMPTY, then increment the front value by one (front++). Then display queue[front] as deleted element. Then check whether both front and rear are equal (front == rear), if it TRUE, then set both front and rear to \'-1\' (front = rear = -1).\n
    </string>

    <string name="que_syn_2">
        <![CDATA[
void deQueue() {
  if (front == rear)
    printf("\nUnderflow. Queue is Empty.");
  else {
    printf("\nDeleted item is: %d", queue[front]);
    front++;
    if (front == rear)
      front = rear = -1;
  }
}
        ]]>
    </string>

    <string name="que_syn_3" formatted="false">
        <![CDATA[
int queue[SIZE], front = -1, rear = -1;

void enQueue(int value) {
  if(rear == SIZE - 1)
    printf("\nOverflow. Queue is Full.");
  else {
    if (front == -1)
  front = 0;
    rear++;
    queue[rear] = value;
    printf("\nInsertion was successful");
  }
}

void deQueue() {
  if (front == rear)
    printf("\nUnderflow. Queue is Empty.");
  else {
    printf("\nDeleted item is: %d", queue[front]);
    front++;
    if (front == rear)
      front = rear = -1;
  }
}

void display() {
  if(rear == -1)
    printf("\nQueue is Empty!");
  else {
    int i;
    printf("\nQueue elements are:\n");
    for (i = front; i<=rear; i++)
      printf("%d\t",queue[i]);
  }
}

void main()
{
  int value, choice;
  while(1) {
    printf("\n----- Queue Using Arrays-----\n");
    printf("1. Insertion\n2. Deletion\n3. Display\n4. Exit");
    printf("\nEnter your choice: ");
    scanf("%d",&choice);
    switch(choice) {
      case 1: printf("Enter the value to be inserted: ");
              scanf("%d",&value);
              enQueue(value);
              break;
      case 2: deQueue();
              break;
      case 3: display();
              break;
      case 4: exit(0);
      default: printf("\nWrong selection, please try again");
    }
  }
}
        ]]>
    </string>

    <!-- Queues Linked List-->

    <string name="before_que_ll">
        Step 1: Include all the header files which are used in the program.\n
        Step 2: Define a \'Node\' structure with two members data and next.\n
        Step 3: Define two Node pointers \'front\' and \'rear\' and set both to NULL.
    </string>

    <string name="enque_ll">
        Step 1: Create a newNode with given value and set \'newNode → next\' to NULL.\n
        Step 2: Check whether queue is Empty (rear == NULL).\n
        Step 3: If it is Empty then, set front = newNode and rear = newNode.\n
        Step 4: If it is Not Empty then, set rear → next = newNode and rear = newNode.
    </string>

    <string name="que_syn_4">
        <![CDATA[
void enQueue(int value)
{
  struct Node *newNode;
  newNode = (struct Node*)malloc(sizeof(struct Node));
  newNode -> data = value;
  newNode -> next = NULL;
  if (front == NULL)
    front = rear = newNode;
  else {
    rear -> next = newNode;
    rear = newNode;
  }
  printf("\nInsertion is Successful\n");
}
        ]]>
    </string>

    <string name="deque_ll">
        Step 1: Create a newNode with given value and set \'newNode → next\' to NULL.\n
        Step 2: Check whether queue is Empty (rear == NULL).\n
        Step 3: If it is Empty then, set front = newNode and rear = newNode.\n
        Step 4: If it is Not Empty then, set rear → next = newNode and rear = newNode.\n
    </string>

    <string name="que_syn_5">
        <![CDATA[
void deQueue()
{
   if (front == NULL)
      printf("\nUnderflow. Queue is Empty\n");
   else {
      struct Node *temp = front;
      front = front -> next;
      printf("\nDeleted element: %d\n", temp -> data);
      free(temp);
   }
}
        ]]>
    </string>

    <string name="que_syn_6" formatted="false">
        <![CDATA[
struct Node
{
   int data;
   struct Node *next;
}*front = NULL, *rear = NULL;

void enQueue(int value)
{
  struct Node *newNode;
  newNode = (struct Node*)malloc(sizeof(struct Node));
  newNode -> data = value;
  newNode -> next = NULL;
  if (front == NULL)
    front = rear = newNode;
  else {
    rear -> next = newNode;
    rear = newNode;
  }
  printf("\nInsertion is Successful\n");
}

void deQueue()
{
  if (front == NULL)
    printf("\nUnderflow. Queue is Empty\n");
  else
  {
    struct Node *temp = front;
    front = front -> next;
    printf("\nDeleted element: %d\n", temp -> data);
    free(temp);
  }
}

void display()
{
  if (front == NULL)
    printf("\nQueue is Empty!\n");
  else {
    struct Node *temp = front;
    while (temp -> next != NULL) {
      printf("%d--->", temp -> data);
      temp = temp -> next;
    }
    printf("%d--->NULL\n", temp -> data);
  }
}

void main()
{
  int choice, value;
  while(1) {
    printf("\nQueue using Linked List\n");
    printf("1. Insert\n2. Delete\n3. Display\n4. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &choice);
    switch(choice) {
      case 1: printf("Enter the value to be inserted: ");
              scanf("%d", &value);
              enQueue(value);
              break;
      case 2: deQueue();
              break;
      case 3: display();
              break;
      case 4: exit(0);
      default: printf("\nWrong choice. Please try again\n");
    }
  }
}
        ]]>
    </string>

    <!--Trees-->

    <string name="what_tree">What is a Tree?</string>

    <string name="what_tree_txt">A tree is a widely used data structure that simulates a hierarchical tree structure, with a root value and the subtrees as children, represented as a set of linked nodes. The children of each node could be accessed by traversing the tree until the specified value is reached.</string>

    <string name="adv_tree">Advantages of trees</string>

    <string name="adv_tree_txt">
        1. Trees (with some ordering e.g., BST) provide moderate access/search (quicker than a Linked List).\n
        2. Trees provide moderate insertion/deletion (quicker than Arrays) speed.\n
    </string>

    <string name="use_program_tree">
        1. File System structure: directories and subdirectories of a file system can be efficiently be represented by trees.\n
        2. DOM structure: HTML pages are rendered using a DOM structure which contains all the tags used in the page under a tree-like structure.\n
        3. Router algorithms: use trees to figure out a path for the data to follow efficiently.\n

    </string>

    <string name="term_tree">Terminology used in trees</string>

    <string name="root">Root</string>
    <string name="root_txt">The first node in a tree is called as Root Node. Every tree must have one Root Node.</string>

    <string name="pnode">Parent Node</string>
    <string name="pnode_txt">The node which is a predecessor of any node is called a Parent Node, that is, the node which has a branch from it to any other node is called as the Parent node.</string>

    <string name="cnode">Child Node</string>
    <string name="cnode_txt">The node which is descendant of any node is called as Child Node. Any parent node can have any number of child nodes. All the nodes except root are child nodes.</string>

    <string name="siblings">Siblings</string>
    <string name="siblings_txt">Nodes which belong to the same Parent are called as Siblings.</string>

    <string name="lnode">Leaf Node</string>
    <string name="lnode_txt">In a tree data structure, the node which does not have a child is called a Leaf Node. They are also known as External Nodes or Terminal Nodes.</string>

    <string name="inode">Internal Node</string>
    <string name="inode_txt">The node which has at least one child is called an Internal Node.</string>

    <string name="enode">External Node</string>
    <string name="enode_txt">The node which has no child is called an External Node.</string>

    <string name="degree">Degree</string>
    <string name="degree_txt">The total number of children of a node is called a Degree of that Node. The highest degree of a node among all the nodes in a tree is called the Degree of the tree.</string>

    <string name="level">Level</string>
    <string name="level_txt">In a tree each step from top to bottom is called as a Level</string>

    <string name="height">Height</string>
    <string name="height_txt">The total number of edges from the leaf node to a particular node in the longest path is called as Height of that Node.</string>

    <string name="depth">Depth</string>
    <string name="depth_txt">The total number of edges from root node to a particular node is called as DEPTH of that Node.</string>

    <string name="path">Path</string>
    <string name="path_txt">The sequence of Nodes and Edges from one node to another node is called as PATH between that two Nodes.</string>

    <string name="tree_types">Types of Trees</string>
    <string name="binary_tree">Binary Tree</string>

    <string name="binary_stree">Binary Search Tree</string>
    <string name="mw_search">Multiway Search Tree</string>
    <string name="avl_tree">AVL Tree</string>


    <string name="binary_tree_traversals">Binary Tree Traversals</string>
    <string name="btt_txt">A binary tree is traversed when one needs to access or display its elements. Each method produces a different order of elements that may be useful in scenarios when needed.</string>

    <string name="trav_meth">Traversal Methods</string>
    <string name="trav_method_txt">Inorder, Preorder and Postorder traversals</string>

    <!--Binary Tree-->

    <string name="what_bt">What is Binary Tree?</string>
    <string name="what_bt_txt">In a normal tree, every node can have any number of children. A Binary tree is a special type of tree in which every node can have a maximum of 2 children.\n
        One is known as the left child and the other as right child.
    </string>

    <string name="property_bt">Properties of Binary Tree</string>
    <string name="property_bt_txt">
        1. The maximum number of nodes at level \'l\' of a binary tree is 2l - 1.\n
        2. Maximum number of nodes in a binary tree of height ‘h’ is 2h – 1.\n
        3. In a binary tree with N nodes, minimum possible height or minimum number of levels is ⌈ log (N+1) ⌉ (ceiling function and log with base 2).\n
        4. A Binary Tree with L leaves has at least ⌈ log L ⌉ + 1 (ceiling function and log with base 2) levels.\n
    </string>

    <string name="bt_rep">Binary Tree Representation</string>
    <string name="bt_rep_txt">A binary tree data structure can be represented using two methods:</string>

    <string name="bt_arr">1. Array Representation</string>
    <string name="bt_arr_txt">The binary tree is represented in a 1-Dimensional array, as shown:</string>
    <!--Need an Image-->
    <string name="bt_ll">2. Linked List Representation</string>
    <string name="bt_ll_txt">A doubly linked list is used to represent a binary tree. Here, every node consists of 3 fields. 

        \n\nFirst field for storing left child\'s address, second for storing data and third for storing right child\'s address.</string>

    <string name="types_bt">Types of Binary Tree</string>
    <string name="sbt">1. Strictly Binary Tree</string>
    <string name="sbt_txt">A binary tree in which every node has either two or zero children is a Strictly Binary Tree</string>
    <string name="cbt">2. Complete Binary Tree</string>
    <string name="cbt_txt">A binary tree in which every internal node has exactly two children and all leaf nodes are at same level is a Complete Binary Tree.</string>
    <string name="ebt">3. Extended Binary Tree</string>
    <string name="ebt_txt">The full binary tree obtained by adding dummy nodes to a binary tree is called as Extended Binary Tree.</string>
    <string name="tbt">4. Threaded Binary Tree</string>
    <string name="tbt_txt">Threaded Binary Tree is also a binary tree in which all left child pointers that are NULL points to its in-order predecessor, and all right child pointers that are NULL points to its in-order successor.</string>

    <!--Binary Search Tree-->

    <string name="what_bst">A Binary Search Tree is a binary tree that additionally satisfies the binary search property.</string>
    <string name="btp">Binary Tree Property</string>

    <string name="btp_txt">This property states that the key in each node must be greater than or equal to any key stored in the left sub-tree, and less than or equal to any key stored in the right sub-tree.</string>

    <string name="opt_bst">Operations in Binary Search Tree</string>
    <string name="searching">Searching</string>
    <string name="searching_bst">
        1. We begin by examining the root node. If the tree is null, the key we are searching for does not exist in the tree.\n
        2. If the key equals that of the root, the search is successful and we return the node.\n
        3. If the key is less than that of the root, we search the left subtree. Similarly, if the key is greater than that of the root, we search the right subtree.\n
        4. This process is repeated until the key is found or the remaining subtree is null.\n
        5. If the searched key is not found after a null subtree is reached, then the key is not present in the tree.\n
    </string>

    <string name="insertion">Insertion</string>
    <string name="insertion_bst">
        To insert for a key in the tree, we follow the binary search property and insert accordingly.\n
        \t1. Compare the key to be searched with the root’s key.\n
        \t2. If the key is lesser than the root’s value, we return the left subtree of the node.\n
        \t3. If the key is greater than the root’s value, we return the right subtree of the node.\n
        \t4. This process is continued until we hit a leaf node. The new node is inserted to this location as a new node.\n
    </string>

    <string name="deletion">Deletion</string>
    <string name="deletion_txt">
        When removing a node from a binary search tree it is mandatory to maintain the in-order sequence of the nodes. There are three possible cases to consider:\n\n
        \t1. Deleting a node with no children: simply remove the node from the tree.\n
        \t2. Deleting a node with one child: remove the node and replace it with its child.\n
        \t3. Deleting a node with two children: First, we find the in-order successor of the node. Then the contents of this in-order successor are copied to the node to be deleted. Finally, the in-order successor is deleted.\n
    </string>


    <string name="tree_syn_1">
        <![CDATA[
struct node
{
  int data;
  struct node* left;
  struct node* right;
};

struct node* createNode(value) {
  struct node* newNode = malloc(sizeof(struct node));
  newNode -> data = value;
  newNode -> left = NULL;
  newNode -> right = NULL;

  return newNode;
}

struct node* insert(struct node* root, int data)
{
  if (root == NULL) 
    return createNode(data);

  if (data < root -> data)
    root -> left  = insert(root -> left, data);
  else if (data > root -> data)
    root -> right = insert(root -> right, data);

  return root;
}

void inorder(struct node* root){
  if (root == NULL) return;
  inorder(root -> left);
  printf("%d ->", root -> data);
  inorder(root -> right);
}


int main(){
  struct node *root = NULL;
  root = insert(root, 8);
  insert(root, 4);
  insert(root, 6);
  insert(root, 3);
  insert(root, 32);
  insert(root, 13);
  insert(root, 16);
  insert(root, 2);

  inorder(root);
}  
        ]]>
    </string>

    <!--Multiway Tree-->

    <string name="what_mwt">What is a Multiway Search Tree</string>
    <string name="what_mwt_txt">
        A multiway tree can have more than one value per node. They are written as m-way trees where the "m" means the order of the tree. A multiway tree can have m-1 values per node and m children. Although, not every node needs to have m-1 values or m children.
    </string>

    <string name="bt">B-Trees</string>

    <string name="bt_what">
        A B-tree is a specialized M-way tree that is widely used for disk access. A B tree of order m can have a maximum of m–1 keys and m pointers to its sub-trees. It was developed in the year of 1972 by Bayer and McCreight.\n\n

        A B-tree is designed to store sorted data and allows search, insertion, and deletion operations to be performed in logarithmic running time.
    </string>

    <string name="properties_bt">
        Properties of B-Trees
    </string>

    <string name="properties_bt_txt">
        1. All the leaf nodes must be at same level.\n
        2. All nodes except root must have at least [m/2]-1 keys and maximum of m-1 keys.\n
        3. A non leaf node with n-1 keys must have n number of children.\n
        4. All the key values within a node must be in Ascending Order.\n
        5. All internal nodes must have at least m/2 children.\n
        6. If the root node is a non leaf node, then it must have at least 2 children.\n
    </string>

    <string name="bp">B+ Tree</string>
    <string name="bp_txt">
        A B+ tree can be viewed as a B-tree in which each node contains only keys (not key–value pairs), and it stores all the records at the leaf level of the tree instead.
    </string>

    <string name="uses_bp">Uses of B+ Tree</string>
    <string name="uses_bp_txt">
        The primary value of a B+ tree is in storing data for efficient retrieval in a block-oriented storage context, like file management.\n\n

        This is because the efficient retrieval of a B+ Tree. The high number of pointers to the child nodes in a node help to reduce the number of I/O operations required to find an element in the tree, making it ideal for data retrieval where I/O operations take time.
    </string>

    <string name="properties_bp">Property of B+ Trees</string>
    <string name="peoperties_bp_txt">
        1. Inserting a record requires O(log n) operations.\n
        2. Finding a record requires O(log n) operations.\n
        3. Removing a (previously located) record requires O(log n) operations.\n
        4. Performing a range query with k elements occurring within the range requires O(log n + k) operations.\n
    </string>

    <!--AVL TREE-->
    <string name="avl">What is an AVL Tree?</string>
    <string name="avl_txt">An AVL tree is a self-balancing binary search tree. A binary tree is said to be balanced, if the difference between the heights of left and right subtrees of every node in the tree is either -1, 0 or +1 . This is known as the Balance Factor.</string>

    <string name="bf">Balance Factor</string>
    <string name="bf_txt">
        The balance factor can be calculated using the following formula:
    </string>
    <string name="bf_for">
        <![CDATA[
    Balance Factor = height(left_subtree) − height(right_subtree)
        ]]>
    </string>

    <string name="reb">Rebalancing</string>
    <string name="reb_txt">
        During a modifying operation (e.g. insert, delete), if the height difference of more than 1 arises between two subtrees, the parent subtree has to be "rebalanced" to satisfy the AVL property.\n\n

        These are done by tree rotations, which moves the keys in such a manner that there order is preserved, but the balance factor is also satisfied.
    </string>

    <string name="tree_rot">AVL Tree Rotations</string>
    <string name="tree_rot_txt">
        Rotation is the process of moving the nodes to either left or right to make tree balanced. There are 4 types of rotations:\n\n
        \t1. Single Left Rotation (LL Rotation)\n
        \t2. Single Right Rotation (RR Rotation)\n
        \t3. Left Right Rotation (LR Rotation)\n
        \t4. Right Left Rotation (RL Rotation)\n\n
        Understanding tree rotations would be hard in text form, please refer to the additional resources to understand them better.\n
    </string>

    <!--Heaps-->
    <string name="what_heap">What is a heap?</string>
    <string name="heap_txt">A heap is a specialized tree-based data structure that satisfies the heap property. It can be of 2 types: max-heap and min-heap.</string>

    <string name="heap_prop">Properties of Heap</string>
    <string name="heap_prop_txt">
        The heap property says that is the value of the Parent is either greater than or equal to (in a max heap) or less than or equal to (in a min-heap) the value of the Child.
    </string>

    <string name="use_heap">
        1. Heapsort: One of the best in-place sorting methods with no quadratic worst-case scenarios. This is because the minimum or maximum element is always the root of the tree.\n
        2. Implementing priority queues: the highest (or lowest) priority element is always stored at the root.\n
        3. Selection algorithms: A heap allows access to the min or max element in constant time, and other selections (such as median or kth-element) can be done in sub-linear time on data that is in a heap.\n
        4. Graph algorithms: By using heaps as internal traversal data structures, run times can be reduced by polynomial order.\n
    </string>

    <!--Operations on heap-->

    <string name="oper_heap">Operations on Heap</string>
    <string name="oper_heap_txt">The following operations are performed on a heap data structure:</string>

    <string name="min_max">Finding Maximum/Minimum</string>
    <string name="min_max_txt">
        Finding the node which has maximum or minimum value is easy. Due to the heap property, it will be always the root node, hence we can access it in constant time
    </string>

    <string name="ins_heap">
        The new heap would not necessarily satisfy the heap property, we have to make it satisfy the heap property.\n\n
        \tStep 1: Insert the node like in a normal tree.\n
        \tStep 2: If the new Node is greater/lesser than its parent, swap it with it\'s parent.
    </string>

    <string name="del_heap">
        An element is always deleted from the root of the heap. So, deleting an element from the heap is done in the following three steps:\n\n
        \tStep 1: Replace the root node’s value with the last node’s value.\n
        \tStep 2: Delete the last node.\n
        \tStep 3: Sink down the new root node’s value so that the heap again satisfies the heap property.\n
    </string>


    <!--GRAPHS-->

    <string name="what_graph">What is a Graph?</string>
    <string name="what_graph_txt">
        A graph data structure is used to represent relations between pairs of objects.\n\n

        It consists of nodes (known as vertices) that are connected through links (known as edges).\n\n

        The relationship between the nodes can be used to model the relation between the objects in the graph. This is what makes graphs important in the real world.\n
    </string>

    <string name="prop_graph">Properties of Graph</string>
    <string name="prop_graph_txt">
        1. A graph G is defined as an ordered set (V, E), where V(G) represents the set of vertices and E(G) represents the edges that connect these vertices.
        2. A graph can be directed or undirected:
    </string>
    <string name="direct_g">Directed Graphs</string>
    <string name="undir_g">Undirected Graphs</string>

    <string name="direct_g_txt">
        In a directed graph, edges form an ordered pair. If there is an edge from A to B, then there is a path from A to B but not from B to A.
    </string>
    <string name="undirect_g_txt">
         In an undirected graph, edges do not have any direction associated with them.
    </string>

    <string name="use_graphs">
        1. Network Models: They are used to represent complex networks models. The networks may include paths in a city or telephone network or a circuit network.\n
        2. In Social Networks: Graphs are also used in social networks like Facebook and LinkedIn, where each connections can be found out between users, for eg. to suggest Mutual Friends.\n
    </string>

    <string name="terms_graph">Terminology used in Graphs</string>

    <string name="vertex">Vertex</string>
    <string name="vertex_txt">A individual data element of a graph is called as Vertex.</string>

    <string name="edge">Edge</string>
    <string name="edge_txt">An edge is a connecting link between two vertices. An Edge is also known as Arc.</string>

    <string name="ug">Undirected Graph</string>
    <string name="ug_txt">A graph with only undirected edges is said to be undirected graph.</string>

    <string name="dg">Directed Graph</string>
    <string name="dg_txt">A graph with only directed edges is said to be directed graph.</string>

    <string name="mg">Mixed Graph</string>
    <string name="mg_txt">A graph with undirected and directed edges is said to be mixed graph.</string>

    <string name="origin">Origin</string>
    <string name="origin_txt">If an edge is directed, its first endpoint is said to be origin of it.</string>

    <string name="destination">Destination</string>
    <string name="destination_txt">
        If an edge is directed, its first endpoint is said to be origin of it and the other endpoint is said to be the destination of the edge.
    </string>

    <string name="adj">Adjacency</string>
    <string name="adj_txt">
        Two node or vertices are adjacent if they are connected to each other through an edge.
    </string>

    <string name="path_g">Path</string>
    <string name="path_g_txt">Path represents a sequence of edges between the two vertices.</string>

    <string name="degree_g">Degree</string>
    <string name="degree_g_txt">Total number of edges connected to a vertex is said to be degree of that vertex.</string>

    <string name="ind">In-Degree</string>
    <string name="ind_txt">Indegree of a vertex is the number of edges which are coming into the vertex.</string>

    <string name="odeg">Out-Degree</string>
    <string name="odeg_txt">Outdegree of vertex is the number of edges which are going out from the vertex.</string>

    <string name="mst">Minimum Spanning Tree (MST)</string>
    <string name="mst_txt">A minimum spanning tree (MST) is a subset of the edges of a connected, edge-weighted (un)directed graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight.</string>

    <string name="sg">Simple Graph</string>
    <string name="sg_txt">
        A graph is said to be simple if there are no parallel and self-loop edges.
    </string>

    <string name="dag">Directed acyclic graph (DAG)</string>
    <string name="dag_txt">
        A directed acyclic graph (DAG) is a graph that is directed and without cycles connecting the other edges. This means that it is impossible to traverse the entire graph starting at one edge.
    </string>

    <string name="wg">Weighted Graph</string>
    <string name="wg_txt">A weighted graph is a graph in which a number (known as the weight) is assigned to each edge. Such weights might represent for example costs, lengths or capacities, depending on the problem.</string>

    <string name="cg">Complete Graph</string>
    <string name="cg_txt">A complete graph is a graph in which each pair of vertices is joined by an edge. A complete graph contains all possible edges.</string>

    <string name="cong">Connected graph</string>
    <string name="cong_txt">A connected graph is an undirected graph in which every unordered pair of vertices in the graph is connected. Otherwise, it is called a disconnected graph.</string>

    <string name="rep_g">Representation of Graphs</string>
    <string name="rep_txt">
        A graph can be represented in memory in 2 ways:
    </string>
    <string name="adjm">1. Adjacency Matrix</string>
    <string name="sdjm_txt">
        In this representation, the graph can be represented using a matrix of size total number of vertices by total number of vertices. Here, rows and columns both represents vertices. This matrix is filled with either 1 or 0.\n\n

        Here, 1 represents there is an edge from row vertex to column vertex and 0 represents there is no edge from row vertex to column vertex.
    </string>

    <string name="adjl">2. Adjacency List</string>
    <string name="adjl_txt">
        In this representation, every vertex of graph contains a linked list of its adjacent vertices.
    </string>

    <string name="gt">Graph Traversals</string>

    <string name="gt_txt">
        Graph traversal is technique used for searching a vertex in a graph. It is also used to decide the order of vertices to be visit in the search process. A traversal algorithms is careful not to get into loops and repeatedly visit the same nodes.\n\n

        There are 2 common graph traversal algorithms:
    </string>

    <string name="bfs">Breadth First Search</string>
    <string name="bfs_txt">Explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.</string>

    <string name="dfs">Depth First Search</string>
    <string name="dfs_txt">Explores as far as possible along each branch before backtracking.</string>

    <string name="oa">Other Algorithms</string>
    <string name="ts">Topological Sorting</string>

    <string name="ts_txt">
        Linear ordering of vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering.
    </string>

    <!--BFS-->

    <string name="bfs_what">
        Breadth-first search (BFS) is a graph search algorithm that begins at the root node and explores all the neighboring nodes. Then for each of those nearest nodes, the algorithm explores their unexplored neighbor nodes, and so on, until it finds the specified node.\n\n

        A queue is used as an auxiliary data structure to keep track of the neighboring nodes.
    </string>

    <string name="bfs_tc">
        In the worst case, breadth-first search has to traverse through all paths to all possible nodes. Therefore, the time complexity can be expressed as O( | E | + | V | ) which is the sum of all vertices(V) and edges(E).
    </string>

    <string name="bfs_sc">
        In the breadth-first search algorithm, all the nodes at a particular level must be saved until their child nodes in the next level have been visited. The space complexity is therefore proportional to the number of nodes at the deepest level of the graph.
    </string>

    <string name="compl">Completeness</string>
    <string name="compl_txt">
        Breadth-first search is said to be a complete algorithm because if there is a solution, breadth-first search will find it regardless of the kind of graph. But in case of an infinite graph where there is no possible solution, it will diverge.
    </string>

    <string name="steps_bsf">Steps to perform BFS</string>
    <string name="steps_bfs_txt">
        Step 1: Define a Queue of size total number of vertices in the graph.\n
        Step 2: Select any vertex as starting point for traversal. Visit that vertex and insert it into the Queue.\n
        Step 3: Visit all the adjacent vertices of the vertex which is at front of the Queue which is not visited and insert them into the Queue.\n
        Step 4: When there is no new vertex to be visit from the vertex at front of the Queue then delete that vertex from the Queue.\n
        Step 5: Repeat step 3 and 4 until queue becomes empty.\n
        Step 6: When queue becomes Empty, then produce final spanning tree by removing unused edges from the graph.\n
    </string>

    <string name="pseudo">Pseudocode</string>
    <string name="bsf_pseudo">
        <![CDATA[
  create a queue Q
  label the starting_vertex as discovered
  Q.enqueue(starting_vertex)
  while Q is not empty:
    v = Q.dequeue()
    if v is the goal:
      return v
    for all edges from v to w in G.adjacentEdges(v) do
      if w is not labeled as discovered:
        label w as discovered
        w.parent = v
        Q.enqueue(w)
        ]]>
    </string>

    <!--DFS-->

    <string name="dfs_what">
        The depth-first search algorithm progresses by expanding the starting node and then going deeper until the goal node is found, or until a node that has no children is encountered. When a dead-end is reached, the algorithm backtracks, returning to the most recent node that has not been completely explored.\n\n

        It uses a stack as an auxiliary data structure.
    </string>

    <string name="tc_dfs">
        The time complexity of a depth-first search is proportional to the number of vertices plus the number of edges in the graphs that are traversed. The time complexity can be given by (O(|V| + |E|)).
    </string>

    <string name="sc_dfs">
        The space complexity of a depth-first search is lower than that of a breadth first search.
    </string>

    <string name="comp_dfs">
        Depth-first search is said to be a complete algorithm. If there is a solution, depth first search will find it regardless of the kind of graph. But in case of an infinite graph, where there is no possible solution, it will diverge.
    </string>

    <string name="steps_dfs">Steps To perform DFS</string>
    <string name="steps_dfs_txt">
        Step 1: Define a Stack of size total number of vertices in the graph.\n
        Step 2: Select any vertex as starting point for traversal. Visit that vertex and push it on to the Stack.\n
        Step 3: Visit any one of the adjacent vertex of the vertex which is at top of the stack which is not visited and push it on to the stack.\n
        Step 4: Repeat step 3 until there are no new vertex to be visit from the vertex on top of the stack.\n
        Step 5: When there is no new vertex to be visit then use back tracking and pop one vertex from the stack.\n
        Step 6: Repeat steps 3, 4 and 5 until stack becomes Empty.\n
        Step 7: When stack becomes Empty, then produce final spanning tree by removing unused edges from the graph.\n
    </string>

    <string name="pseudo_dfs">
        <![CDATA[
procedure iterative-DFS(G,v):
  create a stack S
  S.push(v)
  while S is not empty
      v = S.pop()
      if v is not labeled as discovered:
          label v as discovered
          for all edges from v to w in G.adjacentEdges(v) do
              S.push(w)


        ]]>
    </string>


    <!--TOPOLOGICAL SORT-->

    <string name="topo">Topological Sorting</string>
    <string name="topo_txt">
        A topological sort or topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering.\n\n

        The vertices of the graph may represent tasks to be performed, and the edges may represent constraints that one task must be performed before another. In this application, a topological ordering is just a valid sequence for the tasks.\n\n

        A topological ordering is possible if and only if the graph has no directed cycles, that is if it is a directed acyclic graph (DAG).
    </string>

    <string name="topo_algo">
        There are 2 algorithms for performing a topological sort.\n\n
        \t1. Kahn\'s Algorithm
        \t2. Using Depth First Search
    </string>

    <string name="khans">Kahn\'s Algorithm</string>
    <string name="khans_txt">
        Kahn\'s Algorithm works by finding vertices which have no incoming edges and removing all outgoing edges from these vertices. See the steps and visualisation for a better understanding.\n\n

        \tStep 1: Compute in-degree for each of the vertex present in the DAG and initialize the count of visited nodes as 0.\n
        \tStep 2: Pick all the vertices with in-degree as 0 and add them into a queue.\n
        \tStep 3: Remove a vertex from the queue and then:\n
            \t\t1. Decrease in-degree by 1 for all its neighboring nodes.\n
            \t\t2. If in-degree of a neighboring nodes is reduced to zero, then add it to the queue.\n
        \tStep 4: Repeat Step 3 until the queue is empty.\n
    </string>

    <string name="dfs_app">Depth-first Search Approach</string>
    <string name="dfs_app_txt">
        An alternative approach for topological sorting is based on depth-first search.\n\n

        The algorithm loops through each node of the graph, in an arbitrary order, initiating a depth-first search that terminates when it hits any node that has already been visited since the beginning of the topological sort or the node has no outgoing edges (i.e. a leaf node).\n\n

        This produces the topological order of the nodes.\n
    </string>

    <!--HASH TABLE-->

    <string name="hash_what">What is a Hash Table?</string>
    <string name="hash_what_txt">
        A Hash table is a data structure in which keys are mapped to array positions by a hash function. \n\n

        A value stored in a hash table can then be searched in O(1) time, by using the same hash function which generates an address from the key.\n\n

        The process of mapping the keys to appropriate locations (or indices) in a hash table is called hashing.\n
    </string>

    <string name="adv_hash">Advantages of Hashing</string>
    <string name="adv_hash_txt">
        The main advantage of hash tables over other data structures is speed. The access time of an element is on average O(1), therefore lookup could be performed very fast. Hash tables are particularly efficient when the maximum number of entries can be predicted in advance.
    </string>

    <string name="hf">Hash Functions</string>
    <string name="hf_txt">
        A hash function is a mathematical formula which, when applied to a key, produces an value which can be used as an index for the key in the hash table. The main aim of a hash function is that elements should be uniformly distributed.\n\n

        It produces a unique set of integers within some suitable range in order to reduce the number of collisions.
    </string>

    <string name="prop_hf">Properties of a Good Hash Function </string>

    <string name="unif_hf">Uniformity</string>
    <string name="unif_hf_txt">A good hash function must map the keys as evenly as possible. This means that the probability of generating every hash value in the output range should roughly be the same. This also helps reducing collisions.</string>

    <string name="determ_hf">Deterministic</string>
    <string name="determ_hf_txt">A hash procedure must be deterministic — meaning that for a given input value, the function must always generate the same hash value.</string>

    <string name="lc_hf">Low Cost</string>
    <string name="lc_hf_txt">The cost of executing a hash function must be small, so that using the hashing technique becomes preferable over other traditional approaches.</string>

    <string name="uses_hf">
         1. Identification Databases: A hash function can make a unique signature from never changing data like our Date of Birth. This can then be used in combination of other variables to uniquely identify a person.\n\n

         2. Search Engines: As the number of pages to be crawled is huge, a hash function is used to determine if the page is unique or it had already been crawled before, without comparing the whole webpage.
    </string>

    <string name="diff_hf">Different Hash Functions</string>
    <string name="div_hf">Division Method</string>


    <string name="div_hf_txt">It is the most simple method of hashing an integer x. This method divides x by M and then uses the remainder obtained. Generally, it is best to choose M to be a prime number because making M a prime number increases the likelihood that the keys are mapped with a uniformity in the output range of values. The function could be represented as:</string>
    <string name="div_code">h(k) = k mod M</string>

    <string name="mul_hf">Multiplication Method</string>
    <string name="mul_hf_txt">
        1. Choose a constant A such that 0 A 1.\n
        2. Multiply the key k by A.\n
        3. Extract the fractional part of kA.\n
        4. Multiply the result of Step 3 by the size of hash table (m).\n
        \n\n
        This can be represented as:
    </string>

    <!--TO DO-->

    <string name="mul_code">h(k) = fractional_part[ m (kA mod 1) ]</string>

    <string name="mid_hf">Mid-Square Method</string>
    <string name="mid_hf_txt">
        1. Square the value of the key. That is, find k^2.\n
        2. Extract the middle r digits of the result.\n\n
        The algorithm works well because most or all digits of the key value contribute to the resulting hash.\n
    </string>

    <string name="bh">Bucket Hashing</string>

    <string name="bh_txt">
        One implementation for closed hashing groups hash table slots into buckets.\n\n

        The M slots of the hash table are divided into B buckets, with each bucket consisting of M/B slots. \n\n

        The hash function then assigns each record to the first slot within one of the buckets. \n\n

        If this slot is already occupied, then the bucket slots are searched sequentially until an open slot is found. \n\n

        If a bucket is entirely full, then the record is stored in an overflow bucket of infinite capacity at the end of the table. All buckets share the same overflow bucket.\n\n

        An efficient implementation will use a hash function that distributes the records evenly among the buckets so that as few records as possible go into the overflow bucket.\n\n

    </string>

    <string name="col">Collisions</string>
    <string name="col_txt">
        Collisions occur when the hash function maps two different keys to the same location. As two records cannot be stored in the same location. \n\n

        The method used to solve the problem of collisions is called the collision resolution technique.\n\n

        There are two popular collision resolution techniques:
    </string>

    <string name="oa_hf">Open Addressing</string>
    <string name="oa_txt">
        Once a collision takes place, open addressing or closed hashing computes new positions using a probe sequence and the next record is stored in that position. There are some well known probe sequences:\n\n
        1. Linear Probing: in which the interval between probes is fixed, often 1 is used.\n
        2. Quadratic Probing: in which the interval between probes increases quadratically.\n
        3. Double Hashing: in which the interval between probes is fixed for each record but is computed by another hash function.\n
    </string>

    <string name="sep_hf">Separate Chaining</string>
    <string name="sep_txt">
        In chaining, each location in a hash table stores a pointer to a linked list that contains all the key values that were hashed to that location. As new collisions occur, the linked list grows to accommodate those collisions forming a chain.\n\n

        Searching for a value in a chained hash table is as simple as scanning a linked list for an entry with the given key. Insertion operation appends the key to the end of the linked list pointed by the hashed location. Deleting a key requires searching the list and removing the element.\n
    </string>

    <!-- TODO: Remove or change this placeholder text -->
    <string name="hello_blank_fragment">Hello blank fragment</string>


</resources>
